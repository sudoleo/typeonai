<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>consens.io</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.png" type="image/x-icon">
  <!-- F√ºge dies im <head> hinzu -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Optional f√ºr Sicherheit: -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <script>
    window.FIREBASE_CONFIG = {
      apiKey: "{{ firebase_api_key }}",
      authDomain: "{{ firebase_auth_domain }}",
      projectId: "{{ firebase_project_id }}",
      storageBucket: "{{ firebase_storage_bucket }}",
      messagingSenderId: "{{ firebase_messaging_sender_id }}",
      appId: "{{ firebase_app_id }}"
    };
  </script>
</head>
<body>
<!-- Marketing Popup -->
<div id="marketingPopup" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Welcome to <span class="highlight">consens.io</span></h2>
    <p class="subheading">
      <span style="background-color: rgba(255,215,0,0.4); padding: 0 5px;">
        Don't ask just any AI.<br>
        Ask all of them.
      </span>
    </p>
    <div class="benefits">
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Models:</strong>
        <span>Responses from multiple leading AI models simultaneously.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Answers:</strong>
        <span>AI creats reliable & unified "consensus"</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Search:</strong>
        <span>Real-time web search for accurate, up-to-date results.</span>
      </div>
    </div>
    <p class="cta-text">Log in & get started immediately ‚Äì free.</p>
    <button id="startNowButton" class="cta-button">Get started</button>
  </div>
</div>
  <header class="top-bar">
    <!-- Sidebar Toggle Button -->
    <button id="toggleSidebarButton" class="sidebar-toggle collapse-btn">
      <span class="burger-icon">&#9776;</span>
    </button>
    <!-- Logo und Titel -->
    <div class="top-bar-logo">
      <img src="/static/favicon.png" alt="Favicon" class="top-bar-favicon">
      <span class="top-bar-title">consens.io</span>
    </div>
    <!-- Container f√ºr rechte Elemente -->
    <div class="top-bar-right">
      <div id="loginContainer" class="login-text">Log in and use for free</div>
      <div class="mode-switch">
        <label class="switch">
          <input type="checkbox" id="modeToggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </header>
   
  <br/><br/><br/>
<!-- Sidebar f√ºr API Keys -->
<div class="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-header">
      <h2>
        Endpoints
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Enter your own API keys ‚Äì only necessary without login or when your quota is exhausted.</span>
        </span>
      </h2>
      <button id="toggleApiTest" onclick="toggleApiTest()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="apiTestArea" class="api-test-area">
      <div class="api-key-group">
        <label for="openaiKey">OpenAI API Key <span id="openaiFeedback" class="feedback"></span></label>
        <input type="password" id="openaiKey" placeholder="Your OpenAI Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="mistralKey">Mistral API Key <span id="mistralFeedback" class="feedback"></span></label>
        <input type="password" id="mistralKey" placeholder="Your Mistral Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="anthropicKey">Anthropic API Key <span id="anthropicFeedback" class="feedback"></span></label>
        <input type="password" id="anthropicKey" placeholder="Your Anthropic Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="geminiKey">Google API Key <span id="geminiFeedback" class="feedback"></span></label>
        <input type="password" id="geminiKey" placeholder="Your Gemini Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="deepseekKey">DeepSeek API Key <span id="deepseekFeedback" class="feedback"></span></label>
        <input type="password" id="deepseekKey" placeholder="Your DeepSeek Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="grokKey">Grok API Key <span id="grokFeedback" class="feedback"></span></label>
        <input type="password" id="grokKey" placeholder="Your Grok Key" autocomplete="new-password">
      </div>
      <div class="api-key-group">
        <label for="eaxKey">Exa API Key <span id="exaFeedback" class="feedback"></span></label>
        <input type="password" id="exaKey" placeholder="Your Exa Key" autocomplete="new-password">
      </div>       
      <div class="sidebar-tooltip">
        <button onclick="testAllKeys()">
          Save/Test all APIs 
          <span id="apiSpinner" class="spinner" style="display: none;"></span>
        </button>
        <div class="sidebar-tooltiptext">~1 min.</div>
      </div>      
    </div>
    <div id="usageOptions">
      <label for="useOwnKeysSwitch" class="custom-checkbox-label">
        Use your own API keys
        <input type="checkbox" id="useOwnKeysSwitch">
      </label>
      <span id="freeUsageDisplay">Free requests: ...</span>
    </div>      

    <!-- Trennstrich zwischen API Keys und Modelle -->
    <div class="sidebar-separator"></div>

    <!-- Verwendete Modelle (einklappbar) -->
    <div class="sidebar-header">
      <h2>
        Models
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Choose the models you want to use.</span>
        </span>
      </h2>
      <button id="toggleModelSelection" onclick="toggleModelSelection()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="modelSelectionArea" class="model-selection">
      <label for="selectOpenAI">
        <input type="checkbox" id="selectOpenAI" checked> OpenAI
      </label>
      <label for="selectMistral">
        <input type="checkbox" id="selectMistral" checked> Mistral
      </label>
      <label for="selectClaude">
        <input type="checkbox" id="selectClaude" checked> Anthropic Claude
      </label>
      <label for="selectGemini">
        <input type="checkbox" id="selectGemini" checked> Google Gemini
      </label>
      <label for="selectDeepSeek">
        <input type="checkbox" id="selectDeepSeek" checked> DeepSeek
      </label>
      <label for="selectGrok">
        <input type="checkbox" id="selectGrok" checked> Grok
      </label>
      <label for="selectExa">
        <input type="checkbox" id="selectExa" checked> Exa
      </label>        
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <!-- Leaderboard -->
    <div class="sidebar-header">
      <h2>
        Leaderboard 
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Displays the user leaderboard based on their results.</span>
        </span>
      </h2>
      <button id="toggleLeaderboard" onclick="toggleLeaderboard()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="leaderboardContentContainer" class="hidden">
      <div id="leaderboardContent"></div>
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <div class="sidebar-section">
      <h2>Bookmarks
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">All your chats if you are logged in.</span>
        </span>
      </h2>
      <div id="bookmarksContainer"></div>
    </div>
  </div>
  <!-- Neuer Abschnitt in der Sidebar f√ºr Einstellungen -->
  <div class="sidebar-settings">
    <button id="editSystemPromptBtn" title="Settings">
      <span class="settings-icon">‚öôÔ∏è</span>
      <span class="settings-label">Settings</span>
    </button>
    <span id="version-number">v0.5.0</span>
  </div>
</div>

  <!-- Mode-Switch in der oberen rechten Ecke -->
  <div class="mode-switch">
    <label class="switch">
      <input type="checkbox" id="modeToggle">
      <span class="slider"></span>
    </label>
  </div>

  <div class="container">
    <div class="input-section">
      <div class="chat-input-container" style="position: relative;">
        <textarea class="input-field" id="questionInput" placeholder="Enter your question"></textarea>
        <button id="toggleAllButton" onclick="toggleAllResponses()" title="Collapse or expand all answers">
          <span class="toggle-visual"></span>
        </button>
        <!-- Container f√ºr beide Schalter -->
        <div class="consensus-switch-container" style="position: absolute; bottom: 10px; left: 10px; display: flex; align-items: center; gap: 20px;">
          <!-- Auto-Konsens-Switch -->
          <div class="auto-consensus">
            <label class="switch">
              <input type="checkbox" id="autoConsensusToggle">
              <span class="slider"></span>
            </label>
            <span class="auto-consensus-label">Auto Consensus</span>
          </div>
          <!-- Search Mode Switch, standardm√§√üig leicht ausgegraut -->
          <div class="search-mode">
            <label class="switch">
              <input type="checkbox" id="searchModeToggle">
              <span class="slider"></span>
            </label>
            <span class="search-mode-label">Web Search</span>
            <!-- Disclaimer, der nur beim Aktivieren angezeigt wird -->
            <span id="searchDisclaimer" class="search-disclaimer" style="display: none; font-size: 0.8em; margin-left: 5px;">
              Currently available with ChatGPT, Gemini and Exa. Soon also usable with other models!
            </span>
          </div>
        </div>
        <button class="button" id="sendButton" onclick="sendQuestion()">
          <!-- SVG-Icon f√ºr einen Pfeil, der nach unten zeigt -->
          <svg class="input-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="response-section" style="position: relative;">
      <!-- Antwort OpenAI -->
      <div class="response-box" id="openaiResponse" data-model="OpenAI">
        <h2>
          <span class="title">Response from ChatGPT <small>(GPT-4o)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('openaiResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('openaiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('openaiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Mistral -->
      <div class="response-box" id="mistralResponse" data-model="Mistral">
        <h2>
          <span class="title">Response from Mistral <small>(mistral-large-latest)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('mistralResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('mistralResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('mistralResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Anthropic Claude -->
      <div class="response-box" id="claudeResponse" data-model="Anthropic">
        <h2>
          <span class="title">Response from Claude <small>(claude-3-5-sonnet)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('claudeResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('claudeResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('claudeResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Google Gemini -->
      <div class="response-box" id="geminiResponse" data-model="Google Gemini">
        <h2>
          <span class="title">Response from Gemini <small>(gemini-1.5-pro)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('geminiResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('geminiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('geminiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort DeepSeek -->
      <div class="response-box" id="deepseekResponse" data-model="DeepSeek">
        <h2>
          <span class="title">Response from DeepSeek <small>(DeepSeek-V3)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('deepseekResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('deepseekResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('deepseekResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Grok -->
      <div class="response-box" id="grokResponse" data-model="Grok">
        <h2>
          <span class="title">Response from Grok <small>(grok-2)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('grokResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('grokResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('grokResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Exa -->
      <div class="response-box" id="exaResponse" data-model="Exa">
        <h2>
          <span class="title">Response from Exa <small>(exa)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('exaResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('exaResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('exaResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>  
    </div>
    
    <!-- Konsens-Section -->
    <div class="consensus-section">
      <div class="consensus-wrapper">
        <!-- Konsens-Kontrolle: Schalter, Button und Dropdown wie gehabt -->
        <div class="consensus-controls">
          <!-- Tooltip-Wrapper um den Button -->
          <div class="tooltip">
            <button id="consensusButton" onclick="getConsensus()">Generate Consensus Answer</button>
            <!-- Das Hover-Feld mit weiteren Infos -->
            <div class="tooltiptext">
              Combine four responses into a final, consistent consensus by reconciling contradictions and errors.
            </div>
          </div>
          <div class="consensus-model">
            <label for="consensusModelDropdown" class="consensus-label">Consensus Model:</label>
            <div class="select-wrapper">
              <select id="consensusModelDropdown">
                <option value="OpenAI">GPT‚Äë4o</option>
                <option value="Anthropic">claude-3-5</option>
                <option value="Mistral">mistral-large-latest</option>
                <option value="Google Gemini">gemini-1.5-pro</option>
                <option value="DeepSeek">DeepSeek-V3</option>
                <option value="Grok">grok2</option>
              </select>
            </div>
          </div>
        </div>
        <!-- Konsens-Box mit zwei nebeneinanderliegenden Bereichen -->
        <div class="consensus-box" id="consensusResponse">
          <!-- Linker Bereich: Konsens-Antwort (80%) -->
          <div class="consensus-main">
            <h2>Consensus Answer</h2>
            <p></p>
          </div>
          <!-- Rechter Bereich: Unterschiede (20%) -->
          <div class="consensus-differences">
            <h2>Differences</h2>
            <p></p>
          </div>
        </div>
      </div>
    </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // --------------------------
      // Dark/Light Mode Initialisierung
      // --------------------------
      const modeToggle = document.getElementById("modeToggle");

      function applyTheme(theme) {
        if (theme === "dark") {
          document.body.classList.add("dark-mode");
          modeToggle.checked = true;
        } else {
          document.body.classList.remove("dark-mode");
          modeToggle.checked = false;
        }
      }

      // Lese gespeicherten Wert aus; wenn keiner vorhanden, verwende die Systempr√§ferenz:
      let storedTheme = localStorage.getItem("theme");
      if (!storedTheme) {
        storedTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        localStorage.setItem("theme", storedTheme);
      }
      applyTheme(storedTheme);

      // Schalte den Dark Mode um und speichere die Auswahl:
      modeToggle.addEventListener("change", function() {
        const newTheme = this.checked ? "dark" : "light";
        localStorage.setItem("theme", newTheme);
        applyTheme(newTheme);
      });

      // --- Speichern des Auto Consensus Zustands ---
      const autoConsensusToggle = document.getElementById("autoConsensusToggle");
      // Beim Laden den gespeicherten Zustand auslesen
      let storedAutoConsensus = localStorage.getItem("autoConsensus");
      if (storedAutoConsensus === null) {
        // Falls noch kein Wert gespeichert wurde, Standard: true (an)
        autoConsensusToggle.checked = true;
        localStorage.setItem("autoConsensus", "true");
      } else {
        autoConsensusToggle.checked = storedAutoConsensus === "true";
      }
      // Bei √Ñnderung den neuen Zustand speichern
      autoConsensusToggle.addEventListener("change", function() {
        localStorage.setItem("autoConsensus", this.checked);
      });

      const questionInput = document.getElementById("questionInput");
      // Pr√ºfe, ob der Nutzer eingeloggt ist (z.B. √ºber ein gespeichertes Token)
      const isLoggedIn = !!localStorage.getItem("id_token");
      // Pr√ºfe, ob mindestens ein API Key vorhanden ist
      const hasApiKeys = localStorage.getItem("openaiKey") ||
                        localStorage.getItem("mistralKey") ||
                        localStorage.getItem("anthropicKey") ||
                        localStorage.getItem("geminiKey") ||
                        localStorage.getItem("deepseekKey") ||
                        localStorage.getItem("grokKey") ||
                        localStorage.getItem("exaKey");
      
      if (isLoggedIn || hasApiKeys) {
        questionInput.placeholder = "Enter your question";
      } else {
        questionInput.placeholder = "Please log in or store your own API keys.";
      }
          
      // --------------------------
      // Marketing Popup Initialisierung
      // --------------------------
      // √úberpr√ºfen, ob das Popup schon angezeigt wurde

      const FREE_USAGE_LIMIT = 25;

      if (!localStorage.getItem("marketingPopupShown")) {
        document.getElementById("marketingPopup").style.display = "block";
        document.body.classList.add("modal-open");
      }

      // Popup schlie√üen, wenn auf das "x" geklickt wird
      document.querySelector("#marketingPopup .close").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        document.body.classList.remove("modal-open");
        localStorage.setItem("marketingPopupShown", "true");
      });

      // Popup schlie√üen, wenn der "Jetzt starten"-Button geklickt wird
      document.getElementById("startNowButton").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        localStorage.setItem("marketingPopupShown", "true");
      });

      document.addEventListener("click", function(event) {
        const sidebar = document.querySelector('.sidebar');
        const burgerButton = document.querySelector('.sidebar-toggle');
        
        // Nur auf kleinen Displays
        if (window.innerWidth <= 1400 && sidebar.classList.contains("active")) {
          // Wenn der Klick weder innerhalb der Sidebar noch auf dem Burger-Button erfolgt
          if (!sidebar.contains(event.target) && !event.target.closest('.sidebar-toggle')) {
            sidebar.classList.remove("active");
          }
        }
      });

      // Elemente f√ºr den Search Mode:
      const searchModeToggle = document.getElementById("searchModeToggle");
      const searchDisclaimer = document.getElementById("searchDisclaimer");
      const consensusDropdown = document.getElementById("consensusModelDropdown");
      
      // Checkboxen f√ºr die Modelle:
      const openaiCheckbox = document.getElementById("selectOpenAI");
      const mistralCheckbox = document.getElementById("selectMistral");
      const claudeCheckbox = document.getElementById("selectClaude");
      const geminiCheckbox = document.getElementById("selectGemini");
      const deepseekCheckbox = document.getElementById("selectDeepSeek");
      const grokCheckbox = document.getElementById("selectGrok");
      const exaCheckbox = document.getElementById("selectExa");

      // Label-Container der Checkboxen:
      const mistralLabel = document.querySelector("label[for='selectMistral']");
      const claudeLabel = document.querySelector("label[for='selectClaude']");
      const deepseekLabel = document.querySelector("label[for='selectDeepSeek']");
      const grokLabel = document.querySelector("label[for='selectGrok']");
      const exaLabel = document.querySelector("label[for='selectExa']");

      // Exa standardm√§√üig ausblenden, da es nur im Search Mode verwendet wird:
      exaCheckbox.checked = false;
      exaCheckbox.disabled = true;
      exaLabel.style.display = "none";
      setResponseBoxDisplay("exaResponse", "none");

      // Funktion, um Response-Boxen komplett auszublenden oder einzublenden:
      function setResponseBoxDisplay(id, displayValue) {
        const el = document.getElementById(id);
        if (el) {
          el.style.display = displayValue;
        }
      }

      // Funktion, um Buttons in den Response-Boxen zu deaktivieren/aktivieren:
      function updateButtons(selector, disable) {
        const btns = document.querySelectorAll(selector);
        btns.forEach(btn => {
          if (disable) {
            btn.style.pointerEvents = "none";
            btn.style.opacity = "0.5";
          } else {
            btn.style.pointerEvents = "";
            btn.style.opacity = "";
          }
        });
      }

      // Beispiel f√ºr das Setzen des systemPrompt-Wertes, falls noch nicht gesetzt:
      const defaultPrompt = "Please respond briefly and precisely, focusing only on the essentials.";
      if (!localStorage.getItem("systemPrompt")) {
        localStorage.setItem("systemPrompt", defaultPrompt);
      }

      // √ñffnen des Modals beim Klick auf das Zahnrad
      document.getElementById("editSystemPromptBtn").addEventListener("click", function() {
        const modal = document.getElementById("systemPromptModal");
        const textarea = document.getElementById("systemPromptInput");
        textarea.value = localStorage.getItem("systemPrompt");
        modal.style.display = "block";
      });

      // Schlie√üen des Modals
      document.getElementById("closeSystemPromptModal").addEventListener("click", function() {
        document.getElementById("systemPromptModal").style.display = "none";
      });

      // Speichern des neuen Prompts
      document.getElementById("saveSystemPromptBtn").addEventListener("click", function() {
        const newPrompt = document.getElementById("systemPromptInput").value.trim();
        localStorage.setItem("systemPrompt", newPrompt); // Speichert auch leere Strings!
        document.getElementById("systemPromptModal").style.display = "none";
      });

      // √ñffnen des Hilfemodals beim Klick auf den Hilfebutton
      document.getElementById("helpButton").addEventListener("click", function() {
        document.getElementById("helpModal").style.display = "block";
      });

      // Schlie√üen des Modals beim Klick auf das Schlie√üen-Symbol
      document.getElementById("closeHelpModal").addEventListener("click", function() {
        document.getElementById("helpModal").style.display = "none";
      });

      // Optional: Modal schlie√üen, wenn au√üerhalb geklickt wird
      window.addEventListener("click", function(event) {
        if (event.target === document.getElementById("helpModal")) {
          document.getElementById("helpModal").style.display = "none";
        }
      });

      // Toggle FAQ items with icons
      document.querySelectorAll('.faq-item h3').forEach((question) => {
        question.addEventListener('click', () => {
          const answer = question.nextElementSibling;
          const icon = question.querySelector('.faq-toggle-icon');
          if (!answer.style.display || answer.style.display === 'none') {
            answer.style.display = 'block';
            icon.textContent = 'Ôºç';
          } else {
            answer.style.display = 'none';
            icon.textContent = 'Ôºã';
          }
        });
      });

      // Standardm√§√üig Antworten ausgeblendet (optional)
      document.querySelectorAll('.faq-item p').forEach((answer) => {
        answer.style.display = 'none';
      });

      const freeDisplay = document.getElementById("freeUsageDisplay");
      const idToken = localStorage.getItem("id_token");
      if (idToken && freeDisplay) {
        fetch("/usage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ id_token: idToken })
        })
          .then(response => response.json())
          .then(data => {
            freeDisplay.innerText = "Free requests:\u00A0" + data.remaining + " / " + 25;
          })
          .catch(err => console.error("Error when retrieving the quota:", err));
      }

      // Maximales Wortlimit definieren (z. B. 100 W√∂rter)
      const MAX_WORDS = 300;

      function validateInputText() {
        const text = document.getElementById("questionInput").value.trim();
        const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
        
        if (wordCount > MAX_WORDS) {
          alert(`Die Eingabe √ºberschreitet das erlaubte Wortlimit von ${MAX_WORDS} W√∂rtern (aktuell ${wordCount}).`);
          return false;
        }
        return true;
      }

      document.getElementById("sendButton").addEventListener("click", function(e) {
        if (!validateInputText()) {
          e.preventDefault();
        }
      });

      // --------------------------
      // Event-Listener f√ºr Eingabefelder und Buttons
      // --------------------------
    
      // Frage per Enter (ohne Zeilenumbruch) absenden
      document.getElementById("questionInput").addEventListener("keydown", function(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          // Wenn der Button deaktiviert ist, breche die Ausf√ºhrung ab
          if (document.getElementById("sendButton").disabled) {
            event.preventDefault();
            return;
          }
          event.preventDefault();
          sendQuestion();
        }
      });
    
      document.getElementById("toggleSidebarButton").addEventListener("click", function() {
        const sidebar = document.querySelector(".sidebar");
        sidebar.classList.toggle("collapsed");
      });

      document.getElementById('toggleSidebarButton').addEventListener('click', function() {
        const sidebar = document.querySelector('.sidebar');
        sidebar.classList.toggle('active');
      });
    
      // Fenstergr√∂√üe pr√ºfen ‚Äì wenn <1024px, Sidebar einklappen
      function checkWindowSize() {
        const sidebar = document.querySelector(".sidebar");
        if (window.innerWidth < 1024) {
          sidebar.classList.add("collapsed");
        } else {
          sidebar.classList.remove("collapsed");
        }
        updateToggleButton();
      }
      window.addEventListener("resize", checkWindowSize);
      checkWindowSize(); // Initial
    
      // Aktualisiert den Pfeil des Sidebar-Toggle-Buttons
      function updateToggleButton() {
        const sidebar = document.querySelector(".sidebar");
        const newText = sidebar.classList.contains("collapsed") ? "‚ñ∫" : "‚óÑ";
        const arrow = document.querySelector(".sidebar-toggle .arrow");
        if (arrow) {
          arrow.textContent = newText;
        }
      }

      // Extrahiert aus dem Differences-Text den BestModel-Wert
      function parseBestModel(differencesText) {
        const regex = /BestModel:\s*(.*)/i;
        const match = differencesText.match(regex);
        return match ? match[1].trim() : null;
      }

      // Funktion, um das Popup anzuzeigen
      function showPopup(message) {
        const popup = document.createElement('div');
        popup.className = 'explanation-popup';
        popup.innerText = message;
        document.body.appendChild(popup);
        
        setTimeout(() => {
          popup.style.opacity = '1';
        }, 100);
        
        setTimeout(() => {
          popup.style.opacity = '0';
          setTimeout(() => {
            popup.remove();
          }, 300);
        }, 3000);
      }
    
      // --------------------------
      // Globale Funktionen (f√ºr Inline-Aufrufe)
      // --------------------------

      window.toggleBest = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("excluded")) return;
        // Nur Popup anzeigen, wenn die Antwort nicht bereits als "best" markiert ist
        if (!box.classList.contains("best")) {
          showPopup("You mark this answer as the best answer. This way it will be highlighted and given special attention in the consensus.");
        }
        if (box.classList.contains("best")) {
          box.classList.remove("best");
        } else {
          document.querySelectorAll(".response-box").forEach(b => b.classList.remove("best"));
          box.classList.add("best");
          const model = box.getAttribute("data-model");
          // Direkter Aufruf zur Firebase-Funktion:
          recordModelVote(model, "best");
        }
      };

      // API Testbereich umschalten (f√ºr den Pfeil in der API Keys Section)
      window.toggleApiTest = function() {
        const area = document.getElementById("apiTestArea");
        const button = document.getElementById("toggleApiTest");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };
    
      // Modelle-Auswahl umschalten (f√ºr den Pfeil in der Modelle Section)
      window.toggleModelSelection = function() {
        const area = document.getElementById("modelSelectionArea");
        const button = document.getElementById("toggleModelSelection");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };

      window.toggleAllResponses = function() {
        const responses = document.querySelectorAll('.response-box');
        let shouldCollapse = false;
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          if (content && !content.classList.contains('collapsed')) {
            shouldCollapse = true;
          }
        });
        
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          const arrow = box.querySelector('.collapse-btn .arrow');
          if (shouldCollapse) {
            if (content && !content.classList.contains('collapsed')) {
              content.classList.add('collapsed');
            }
            if (arrow && !arrow.classList.contains('rotated')) {
              arrow.classList.add('rotated');
            }
          } else {
            if (content && content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
            }
            if (arrow && arrow.classList.contains('rotated')) {
              arrow.classList.remove('rotated');
            }
          }
        });
      };
    
      // Collapse/Expand einer Antwort-Box
      window.toggleCollapse = function(responseId) {
        const responseBox = document.getElementById(responseId);
        const content = responseBox.querySelector(".collapsible-content");
        const arrow = responseBox.querySelector(".collapse-btn .arrow");
        content.classList.toggle("collapsed");
        arrow.classList.toggle("rotated");
      };
    
      // Exclude/Include einer Antwort-Box (falls nicht als "best" markiert)
      window.toggleExclude = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("best")) return;
        // Nur Popup anzeigen, wenn die Antwort nicht bereits ausgeschlossen ist
        if (!box.classList.contains("excluded")) {
          showPopup("You have excluded this answer. It will be removed from the view and not included in the consensus.");
        }
        box.classList.toggle("excluded");
      };
    
      let leaderboardInterval; // Variable zum Speichern des Interval-IDs

      window.toggleLeaderboard = function() {
        const container = document.getElementById("leaderboardContentContainer");
        const arrow = document.getElementById("toggleLeaderboard").querySelector(".arrow");
        container.classList.toggle("hidden");
        arrow.classList.toggle("rotated");
      };

      // Globale Variable
      let consensusGenerated = false;
      document.getElementById("consensusButton").disabled = true;

      // Senden der Frage an die aktiven Modelle
      window.sendQuestion = async function() {
        // √úberpr√ºfe zuerst das Wortlimit. Falls √ºberschritten, wird die Funktion beendet.
        if (!validateInputText()) {
          return;
        }
        const question = document.getElementById("questionInput").value;
        consensusGenerated = false;
        if (!question) {
          alert("Please enter a question.");
          return;
        }
        document.getElementById("sendButton").disabled = true;
        // Konsens-Button wieder aktivieren, bevor eine neue Anfrage gesendet wird.
        document.getElementById("consensusButton").disabled = false;
        const spinnerHTML = '<span class="spinner"></span>';
        // Lese den benutzerdefinierten Systemprompt aus oder nutze den Standardwert
        const customSystemPrompt = localStorage.getItem("systemPrompt") || "Please respond briefly and precisely, focusing only on the essentials.";
        console.log("Using system prompt:", customSystemPrompt);
        
        // Beispiel f√ºr den Payload f√ºr OpenAI:
        const payload = {
          question: question,
          active_count: 1,
          search_mode: document.getElementById("searchModeToggle").checked,
          system_prompt: customSystemPrompt
        };

        // Konsens-Button deaktivieren, solange noch Antworten fehlen
        const consensusBtn = document.getElementById("consensusButton");
        consensusBtn.disabled = true;
        totalRequiredResponses = 0;

        const openaiBox = document.getElementById("openaiResponse");
        const mistralBox = document.getElementById("mistralResponse");
        const claudeBox = document.getElementById("claudeResponse");
        const geminiBox = document.getElementById("geminiResponse");
        const deepseekBox = document.getElementById("deepseekResponse");
        const grokBox = document.getElementById("grokResponse");
        const exaBox = document.getElementById("exaResponse");
        
        // Z√§hle nur die Modelle, die nicht als "ausgeschlossen" markiert sind
        if (!openaiBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!mistralBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!claudeBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!geminiBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!deepseekBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!grokBox.classList.contains("excluded")) totalRequiredResponses++;
        if (document.getElementById("searchModeToggle").checked && !exaBox.classList.contains("excluded")) totalRequiredResponses++;

        let activeModels = [];
        if (document.getElementById("selectOpenAI").checked) activeModels.push("OpenAI");
        if (document.getElementById("selectMistral").checked) activeModels.push("Mistral");
        if (document.getElementById("selectClaude").checked) activeModels.push("Anthropic");
        if (document.getElementById("selectGemini").checked) activeModels.push("Google Gemini");
        if (document.getElementById("selectDeepSeek").checked) activeModels.push("DeepSeek");
        if (document.getElementById("selectGrok").checked) activeModels.push("Grok");
        if (document.getElementById("selectExa").checked && document.getElementById("searchModeToggle").checked) activeModels.push("Exa");
    
        // Spinner in den jeweiligen Response-Boxen setzen
        if (activeModels.includes("OpenAI")) {
          document.getElementById("openaiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Mistral")) {
          document.getElementById("mistralResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Anthropic")) {
          document.getElementById("claudeResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Google Gemini")) {
          document.getElementById("geminiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("DeepSeek")) {
          document.getElementById("deepseekResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Grok")) {
          document.getElementById("grokResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Exa")) {
          document.getElementById("exaResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (document.getElementById("autoConsensusToggle").checked) {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = spinnerHTML;
        } else {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = "";
        }
    
        // API Keys aus localStorage abrufen
        const openaiKey = localStorage.getItem("openaiKey") || "";
        const mistralKey = localStorage.getItem("mistralKey") || "";
        const anthropicKey = localStorage.getItem("anthropicKey") || "";
        const geminiKey = localStorage.getItem("geminiKey") || "";
        const deepseekKey = localStorage.getItem("deepseekKey") || "";
        const grokKey = localStorage.getItem("grokKey") || "";
        const exaKey = localStorage.getItem("exaKey") || "";
    
        let responsesReceived = 0;
        const totalActive = activeModels.length;
        function checkAllResponses() {
          responsesReceived++;
          if (responsesReceived === totalActive) {
            // Sende-Button immer wieder freischalten
            document.getElementById("sendButton").disabled = false;
            
            if (document.getElementById("autoConsensusToggle").checked) {
              // Auto Consensus ist aktiviert: 
              // Den Consensus-Button vor√ºbergehend deaktivieren und
              // erst nach Abschluss der Konsensgenerierung wieder aktivieren.
              document.getElementById("consensusButton").disabled = true;
              getConsensus()
                .then(() => {
                  document.getElementById("consensusButton").disabled = false;
                })
                .catch((error) => {
                  console.error("Fehler bei der Konsensgenerierung:", error);
                  document.getElementById("consensusButton").disabled = false;
                });
            } else {
              // Auto Consensus nicht aktiviert ‚Äì beide Buttons direkt freigeben.
              document.getElementById("consensusButton").disabled = false;
            }
          }
        }

      // Hilfsfunktion, um einen leeren API Key zu pr√ºfen
      function validateUserKey(keyName) {
        const key = localStorage.getItem(keyName);
        return key && key.trim() !== "";
      }

      function addCopyButtons(container) {
        container.querySelectorAll('pre').forEach(function(pre) {
          // Falls bereits ein Copy-Button existiert, √ºberspringen
          if (pre.querySelector('.copy-btn')) return;
          
          var btn = document.createElement('button');
          // Verwende ein dezentes Clipboard-Symbol
          btn.textContent = 'üìã';
          btn.className = 'copy-btn';
          pre.appendChild(btn);
          
          btn.addEventListener('click', function() {
            // Falls ein <code> innerhalb des <pre> existiert, kopiere dessen innerText
            var codeElement = pre.querySelector('code');
            var codeText = codeElement ? codeElement.innerText : pre.innerText;
            navigator.clipboard.writeText(codeText).then(function() {
              btn.textContent = '‚úì';
              setTimeout(function() {
                btn.textContent = 'üìã';
              }, 2000);
            });
          });
        });
      }

      // Mache addCopyButtons global verf√ºgbar:
      window.addCopyButtons = addCopyButtons;

      // OpenAI
      if (activeModels.includes("OpenAI")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,  // Passe diesen Wert ggf. dynamisch an
          // Hier wird der neue Parameter hinzugef√ºgt:
          search_mode: document.getElementById("searchModeToggle").checked,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("openaiKey") || "";
          }
        } else {
          if (!validateUserKey("openaiKey")) {
            alert("Please enter a valid OpenAI API key.");
            return;
          }
          payload.api_key = localStorage.getItem("openaiKey");
        }

        fetch('/ask_openai', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("openaiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "OpenAI");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei OpenAI:", error);
            checkAllResponses();
          });
      }


      // Mistral
      if (activeModels.includes("Mistral")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("mistralKey") || "";
          }
        } else {
          if (!validateUserKey("mistralKey")) {
            alert("Please enter a valid Mistral API key.");
            return;
          }
          payload.api_key = localStorage.getItem("mistralKey");
        }

        fetch('/ask_mistral', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("mistralResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Mistral");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Mistral:", error);
            checkAllResponses();
          });
      }

      // Anthropic Claude
      if (activeModels.includes("Anthropic")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("anthropicKey") || "";
          }
        } else {
          if (!validateUserKey("anthropicKey")) {
            alert("Please enter a valid Anthropic API Key.");
            return;
          }
          payload.api_key = localStorage.getItem("anthropicKey");
        }

        fetch('/ask_claude', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("claudeResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Anthropic");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Anthropic:", error);
            checkAllResponses();
          });
      }

      // Google Gemini
      if (activeModels.includes("Google Gemini")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            active_count: 1,
            // Suche-Parameter hinzuf√ºgen:
            search_mode: document.getElementById("searchModeToggle").checked,
            system_prompt: customSystemPrompt
          };

          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("geminiKey") || "";
            }
          } else {
            if (!validateUserKey("geminiKey")) {
              alert("Please enter a valid Google Gemini API Key.");
              return;
            }
            payload.api_key = localStorage.getItem("geminiKey");
          }

          fetch('/ask_gemini', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("geminiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Gemini");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Google Gemini:", error);
            checkAllResponses();
          });
      }

      // DeepSeek
      if (activeModels.includes("DeepSeek")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("deepseekKey") || "";
          }
        } else {
          if (!validateUserKey("deepseekKey")) {
            alert("Please enter a valid DeepSeek API key.");
            return;
          }
          payload.api_key = localStorage.getItem("deepseekKey");
        }

        fetch('/ask_deepseek', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("deepseekResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "DeepSeek");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests:" + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei DeepSeek:", error);
            checkAllResponses();
          });
      }

      // Grok
      if (activeModels.includes("Grok")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };
        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("grokKey") || "";
          }
        } else {
          if (!validateUserKey("grokKey")) {
            alert("Please enter a valid Grok API key.");
            return;
          }
          payload.api_key = localStorage.getItem("grokKey");
        }
        fetch('/ask_grok', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
        .then(response => response.json())
        .then(data => {
          const outputEl = document.getElementById("grokResponse").querySelector(".collapsible-content");
          if (data.response) {
            outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            addCopyButtons(outputEl);
            if (auth.currentUser) {
              saveBookmark(question, data.response, "Grok");
            }
          } else if (data.error) {
            outputEl.innerText = data.error;
          } else {
            outputEl.innerText = "Please log in or store your own API keys.";
          }
          if (data.free_usage_remaining !== undefined) {
            document.getElementById("freeUsageDisplay").innerText =
              "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
          }
          checkAllResponses();
        })
        .catch(error => {
          console.error("Fehler bei Grok:", error);
          checkAllResponses();
        });
      }

      // Exa
      if (activeModels.includes("Exa")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt,
          search_mode: document.getElementById("searchModeToggle").checked  // optional, falls ben√∂tigt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            // Nehme hier den Exa API-Key (z.‚ÄØB. gespeichert unter "exaKey")
            payload.api_key = localStorage.getItem("exaKey") || "";
          }
        } else {
          if (!validateUserKey("exaKey")) {
            alert("Please enter a valid Exa API key.");
            return;
          }
          payload.api_key = localStorage.getItem("exaKey");
        }

        fetch('/ask_exa', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("exaResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Exa");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Exa:", error);
            checkAllResponses();
          });
        }
    };
    
      // Modelle (Checkboxen) ein-/ausschalten
      window.toggleModel = function(responseId, isChecked) {
        const box = document.getElementById(responseId);
        if (!isChecked) {
          box.classList.add("excluded");
        } else {
          box.classList.remove("excluded");
        }
      };
      document.getElementById("selectOpenAI").addEventListener("change", function() {
        toggleModel("openaiResponse", this.checked);
      });
      document.getElementById("selectMistral").addEventListener("change", function() {
        toggleModel("mistralResponse", this.checked);
      });
      document.getElementById("selectClaude").addEventListener("change", function() {
        toggleModel("claudeResponse", this.checked);
      });
      document.getElementById("selectGemini").addEventListener("change", function() {
        toggleModel("geminiResponse", this.checked);
      });
      document.getElementById("selectDeepSeek").addEventListener("change", function() {
        toggleModel("deepseekResponse", this.checked);
      });
      document.getElementById("selectGrok").addEventListener("change", function() {
        toggleModel("grokResponse", this.checked);
      });
      document.getElementById("selectExa").addEventListener("change", function() {
        toggleModel("exaResponse", this.checked);
      });
    
      // Erneut API Keys in Felder schreiben (falls ben√∂tigt)
      ["openaiKey", "mistralKey", "anthropicKey", "geminiKey", "deepseekKey", "grokKey", "exaKey"].forEach(function(key) {
        const stored = localStorage.getItem(key);
        if (stored) {
          document.getElementById(key).value = stored;
        }
      });

    // Search Mode Toggle: Modelle automatisch anpassen, wenn aktiviert
    //const searchModeToggle = document.getElementById("searchModeToggle");
    //const searchDisclaimer = document.getElementById("searchDisclaimer");

    function showDisclaimerPopup() {
      const popup = document.getElementById('disclaimerPopup');
      popup.classList.add('show');
      // Popup nach 3 Sekunden wieder ausblenden
      setTimeout(() => {
        popup.classList.remove('show');
      }, 5000);
    }

    searchModeToggle.addEventListener("change", function() {
      const isSearchMode = this.checked;

      // Hole das Konsens-Dropdown
      const consensusDropdown = document.getElementById("consensusModelDropdown");

      if (isSearchMode) {
        // Zeige den Disclaimer an (ggf. sp√§ter wieder ausblenden, wenn auf kleinen Bildschirmen ein Popup verwendet wird)
        searchDisclaimer.style.display = "inline-block";

        // Deaktiviere und deaktiviere die nicht ben√∂tigten Modelle (Mistral, Anthropic/Claude, DeepSeek, Grok)
        mistralCheckbox.checked = false;
        claudeCheckbox.checked = false;
        deepseekCheckbox.checked = false;
        grokCheckbox.checked = false;

        mistralCheckbox.disabled = true;
        claudeCheckbox.disabled = true;
        deepseekCheckbox.disabled = true;
        grokCheckbox.disabled = true;

        // Optional: Setze die zugeh√∂rigen Response-Boxen als "ausgeschlossen" (hier zus√§tzlich komplett ausblenden)
        setResponseBoxDisplay("mistralResponse", "none");
        setResponseBoxDisplay("claudeResponse", "none");
        setResponseBoxDisplay("deepseekResponse", "none");
        setResponseBoxDisplay("grokResponse", "none");

        // Blende auch die zugeh√∂rigen Labels aus:
        mistralLabel.style.display = "none";
        claudeLabel.style.display = "none";
        deepseekLabel.style.display = "none";
        grokLabel.style.display = "none";

        // Deaktiviere zus√§tzlich die Buttons in den Response-Boxen (falls noch sichtbar)
        updateButtons("#mistralResponse .best-btn, #mistralResponse .exclude-btn", true);
        updateButtons("#claudeResponse .best-btn, #claudeResponse .exclude-btn", true);
        updateButtons("#deepseekResponse .best-btn, #deepseekResponse .exclude-btn", true);
        updateButtons("#grokResponse .best-btn, #grokResponse .exclude-btn", true);

        // Zeige Exa und reaktiviere sie:
        exaCheckbox.disabled = false;
        exaCheckbox.checked = true;
        exaLabel.style.removeProperty("display");
        exaCheckbox.style.removeProperty("display");
        setResponseBoxDisplay("exaResponse", "block");

        // Setze das Konsens-Dropdown automatisch auf OpenAI und deaktiviere die Auswahl:
        consensusDropdown.value = "OpenAI";
        consensusDropdown.disabled = true;

      // Auf kleinen Bildschirmen: Popup statt Inline-Disclaimer
      if (window.innerWidth < 1400) {
        showDisclaimerPopup();
        searchDisclaimer.style.display = "none";
      }
      } else {
        // Suchmodus ist deaktiviert:
        // Blende den Disclaimer aus
        searchDisclaimer.style.display = "none";

        // Reaktiviere alle Modelle:
        mistralCheckbox.disabled = false;
        claudeCheckbox.disabled = false;
        deepseekCheckbox.disabled = false;
        grokCheckbox.disabled = false;

        // Setze die Checkboxen der Modelle (au√üer Exa) auf "angew√§hlt":
        mistralCheckbox.checked = true;
        claudeCheckbox.checked = true;
        deepseekCheckbox.checked = true;
        grokCheckbox.checked = true;

        // Zeige die Response-Boxen wieder:
        setResponseBoxDisplay("mistralResponse", "block");
        setResponseBoxDisplay("claudeResponse", "block");
        setResponseBoxDisplay("deepseekResponse", "block");
        setResponseBoxDisplay("grokResponse", "block");

        // Zeige die zugeh√∂rigen Labels wieder an ‚Äì einmalig, ohne Duplikate:
        mistralLabel.style.removeProperty("display");
        claudeLabel.style.removeProperty("display");
        deepseekLabel.style.removeProperty("display");
        grokLabel.style.removeProperty("display");
        //exaLabel.style.removeProperty("display");

        // (Exa wird bereits unten ausgeblendet.)
        exaCheckbox.disabled = true;
        exaCheckbox.checked = false;
        setResponseBoxDisplay("exaResponse", "none");
        exaCheckbox.style.display = "none";
        exaLabel.style.display = "none";

        // Reaktiviere die Buttons in den Response-Boxen:
        updateButtons("#mistralResponse .best-btn, #mistralResponse .exclude-btn", false);
        updateButtons("#claudeResponse .best-btn, #claudeResponse .exclude-btn", false);
        updateButtons("#deepseekResponse .best-btn, #deepseekResponse .exclude-btn", false);
        updateButtons("#grokResponse .best-btn, #grokResponse .exclude-btn", false);

        consensusButton.disabled = true;

        // Reaktiviere das Konsens-Dropdown:
        consensusDropdown.disabled = false;
      }
    });
    
      // Globale Variable, um die letzte verarbeitete Frage zu speichern.
      let lastQuestion = "";

      window.getConsensus = async function() {
        const question = document.getElementById("questionInput").value.trim();
          // Status, ob eigene API Keys genutzt werden sollen
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        let searchMode = document.getElementById("searchModeToggle").checked;
        
        // Nur im Gratis-Modus id_token abrufen
        const id_token = useOwnKeys ? null : localStorage.getItem("id_token");

        // Wenn die Frage neu oder ge√§ndert ist, werden Firebase-Votes aktualisiert.
        if (question !== lastQuestion) {
          // F√ºr jedes Modell pr√ºfen, ob es als "best" markiert ist.
          if (document.getElementById("openaiResponse").classList.contains("best")) {
            recordModelVote("OpenAI", "best");
          }
          if (document.getElementById("mistralResponse").classList.contains("best")) {
            recordModelVote("Mistral", "best");
          }
          if (document.getElementById("claudeResponse").classList.contains("best")) {
            recordModelVote("Anthropic", "best");
          }
          if (document.getElementById("geminiResponse").classList.contains("best")) {
            recordModelVote("Gemini", "best");
          }
          if (document.getElementById("deepseekResponse").classList.contains("best")) {
            recordModelVote("DeepSeek", "best");
          }
          if (document.getElementById("grokResponse").classList.contains("best")) {
            recordModelVote("Grok", "best");
          }
          if (searchMode && document.getElementById("exaResponse").classList.contains("best")) {
            recordModelVote("Exa", "best");
          }

          // Ebenso f√ºr "excluded" (sofern du das separat erfassen m√∂chtest).
          if (document.getElementById("openaiResponse").classList.contains("excluded")) {
            recordModelVote("OpenAI", "exclude");
          }
          if (document.getElementById("mistralResponse").classList.contains("excluded")) {
            recordModelVote("Mistral", "exclude");
          }
          if (document.getElementById("claudeResponse").classList.contains("excluded")) {
            recordModelVote("Anthropic", "exclude");
          }
          if (document.getElementById("geminiResponse").classList.contains("excluded")) {
            recordModelVote("Gemini", "exclude");
          }
          if (document.getElementById("deepseekResponse").classList.contains("excluded")) {
            recordModelVote("DeepSeek", "exclude");
          }
          if (document.getElementById("grokResponse").classList.contains("excluded")) {
            recordModelVote("Grok", "exclude");
          }
          if (searchMode && document.getElementById("exaResponse").classList.contains("excluded")) {
            recordModelVote("Exa", "exclude");
          }

          // Aktualisiere die letzte verarbeitete Frage.
          lastQuestion = question;
        }

        // Setze den Konsens-Bereich (Spinner etc.) und rufe anschlie√üend deinen Konsens-Endpunkt auf.
        const consensusDiv = document.getElementById("consensusResponse");
        const mainSpinner = '<span class="spinner"></span>';
        const diffSpinner = '<span class="spinner"></span>';

        consensusDiv.querySelector(".consensus-main p").innerHTML = mainSpinner;
        consensusDiv.querySelector(".consensus-differences p").innerHTML = diffSpinner;

      const consensus_model = document.getElementById("consensusModelDropdown").value;

      // Hole die Antwort-Boxen
      const openaiBox = document.getElementById("openaiResponse");
      const mistralBox = document.getElementById("mistralResponse");
      const claudeBox = document.getElementById("claudeResponse");
      const geminiBox = document.getElementById("geminiResponse");
      const deepseekBox = document.getElementById("deepseekResponse");
      const grokBox = document.getElementById("grokResponse");
      const exaBox = document.getElementById("exaResponse");

      // Lies die Antworten (trim f√ºr √ºberfl√ºssige Leerzeichen)
      const answer_openai = openaiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_mistral = mistralBox.querySelector(".collapsible-content").innerText.trim();
      const answer_claude = claudeBox.querySelector(".collapsible-content").innerText.trim();
      const answer_gemini = geminiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_deepseek = deepseekBox.querySelector(".collapsible-content").innerText.trim();
      const answer_grok = grokBox.querySelector(".collapsible-content").innerText.trim();
      const answer_exa = exaBox.querySelector(".collapsible-content").innerText.trim();

      // √úberpr√ºfe nur die Modelle, die nicht als "ausgeschlossen" markiert sind.
      if (
        !question ||
        !consensus_model ||
        // √úberpr√ºfe immer OpenAI und Gemini:
        (!openaiBox.classList.contains("excluded") && !answer_openai) ||
        (!geminiBox.classList.contains("excluded") && !answer_gemini) ||
        // Wenn Search Mode aktiv ist, pr√ºfe Exa, ansonsten die anderen Modelle:
        (searchMode 
          ? (!exaBox.classList.contains("excluded") && !answer_exa)
          : (
              (!mistralBox.classList.contains("excluded") && !answer_mistral) ||
              (!claudeBox.classList.contains("excluded") && !answer_claude) ||
              (!deepseekBox.classList.contains("excluded") && !answer_deepseek) ||
              (!grokBox.classList.contains("excluded") && !answer_grok)
            )
        )
      ) {
        alert("Refresh the page. Please send a question first, retrieve all answers and select the consensus model.");
        return;
      }

      // Hole den best markierten Modus (falls vorhanden)
      const bestBox = document.querySelector(".response-box.best");
      let best_model = bestBox ? bestBox.getAttribute("data-model") : "";

      // Die √ºbrigen Parameter wie "excluded_models" werden wie bisher ermittelt
      const excludedModels = [];
      if (openaiBox.classList.contains("excluded")) {
        excludedModels.push(openaiBox.getAttribute("data-model"));
      }
      if (mistralBox.classList.contains("excluded")) {
        excludedModels.push(mistralBox.getAttribute("data-model"));
      }
      if (claudeBox.classList.contains("excluded")) {
        excludedModels.push(claudeBox.getAttribute("data-model"));
      }
      if (geminiBox.classList.contains("excluded")) {
        excludedModels.push(geminiBox.getAttribute("data-model"));
      }
      if (deepseekBox.classList.contains("excluded")) {
        excludedModels.push(deepseekBox.getAttribute("data-model"));
      }
      if (grokBox.classList.contains("excluded")) {
        excludedModels.push(grokBox.getAttribute("data-model"));
      }
      if (exaBox.classList.contains("excluded")) {
        excludedModels.push(exaBox.getAttribute("data-model"));
      }

      // Hole API Keys aus localStorage
      const openaiKey = localStorage.getItem("openaiKey") || "";
      const mistralKey = localStorage.getItem("mistralKey") || "";
      const anthropicKey = localStorage.getItem("anthropicKey") || "";
      const geminiKey = localStorage.getItem("geminiKey") || "";
      const deepseekKey= localStorage.getItem("deepseekKey") || "";
      const grokKey= localStorage.getItem("grokKey") || "";
      const exaKey= localStorage.getItem("exaKey") || "";

      try {
        const response = await fetch("/consensus", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            id_token: id_token,
            useOwnKeys: useOwnKeys,
            question: question,
            search_mode: searchMode,
            answer_openai: answer_openai,
            answer_mistral: answer_mistral,
            answer_claude: answer_claude,
            answer_gemini: answer_gemini,
            answer_deepseek: answer_deepseek,
            answer_grok: answer_grok,
            answer_exa: answer_exa,
            best_model: best_model,
            consensus_model: consensus_model,
            excluded_models: excludedModels,
            openai_key: openaiKey,
            mistral_key: mistralKey,
            anthropic_key: anthropicKey,
            gemini_key: geminiKey,
            deepseek_key: deepseekKey,
            grok_key: grokKey,
            exa_key: exaKey,
            keepalive: true
          })
        });
        const data = await response.json();
        if (response.ok) {
          // Aktualisiere den Konsens-Bereich und den Unterschiede-Bereich
          consensusDiv.querySelector(".consensus-main p").innerHTML = marked.parse(data.consensus_response);
          consensusDiv.querySelector(".consensus-differences p").innerHTML = marked.parse(data.differences || "No differences found.");
          const consensusMainEl = consensusDiv.querySelector(".consensus-main p");
          consensusMainEl.innerHTML = marked.parse(data.consensus_response);
          addCopyButtons(consensusMainEl);

          if (auth.currentUser) {
            saveBookmarkConsensus(question, data.consensus_response, data.differences);
          }

          // Parse den BestModel-Wert aus den Unterschieden und aktualisiere das Leaderboard in Firebase
          const bestModelFromConsensus = parseBestModel(data.differences);
          if (bestModelFromConsensus) {
            recordModelVote(bestModelFromConsensus, "BestModel");
          }
        } else {
          consensusDiv.querySelector(".consensus-main p").innerText = "Error: " + data.detail;
          consensusDiv.querySelector(".consensus-differences p").innerText = "";
        }
      } catch (error) {
        console.error("Error fetching consensus:", error);
        consensusDiv.querySelector(".consensus-main p").innerText = "Error in the consensus calculation.";
        consensusDiv.querySelector(".consensus-differences p").innerText = "";
      }
    };
    
      // Testet die API Keys und aktualisiert das Feedback
      window.testAllKeys = async function() {
        const openaiKey = document.getElementById("openaiKey").value;
        const mistralKey = document.getElementById("mistralKey").value;
        const anthropicKey = document.getElementById("anthropicKey").value;
        const geminiKey = document.getElementById("geminiKey").value;
        const deepseekKey = document.getElementById("deepseekKey").value;
        const grokKey = document.getElementById("grokKey").value;
        const exaKey = document.getElementById("exaKey").value;
        localStorage.setItem("openaiKey", openaiKey);
        localStorage.setItem("mistralKey", mistralKey);
        localStorage.setItem("anthropicKey", anthropicKey);
        localStorage.setItem("geminiKey", geminiKey);
        localStorage.setItem("deepseekKey", deepseekKey);
        localStorage.setItem("grokKey", grokKey);
        localStorage.setItem("exaKey", exaKey);
        const spinner = document.getElementById("apiSpinner");
        spinner.style.display = "inline-block";
        try {
          const response = await fetch("/check_keys", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              openai_key: openaiKey,
              mistral_key: mistralKey,
              anthropic_key: anthropicKey,
              gemini_key: geminiKey,
              deepseek_key: deepseekKey,
              grok_key: grokKey,
              exa_key: exaKey
            })
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText);
          }
          const data = await response.json();
          console.log("Response von /check_keys:", data);
          if (!data || !data.results) {
            throw new Error("The response does not contain a 'results' object. Response: " + JSON.stringify(data));
          }
          const openaiResult = data.results["OpenAI"];
          const mistralResult = data.results["Mistral"];
          const anthropicResult = data.results["Anthropic"];
          const geminiResult = data.results["Google Gemini"];
          const deepseekResult = data.results["DeepSeek"];
          const grokResult = data.results["Grok"];
          const exaResult = data.results["Exa"];
          const openaiFeedback = document.getElementById("openaiFeedback");
          const mistralFeedback = document.getElementById("mistralFeedback");
          const anthropicFeedback = document.getElementById("anthropicFeedback");
          const geminiFeedback = document.getElementById("geminiFeedback");
          const deepseekFeedback = document.getElementById("deepseekFeedback");
          const grokFeedback = document.getElementById("grokFeedback");
          const exaFeedback = document.getElementById("exaFeedback");
          openaiFeedback.innerHTML = openaiResult === "valid" ? "&#10003;" : "&#10007;";
          openaiFeedback.style.color = openaiResult === "valid" ? "green" : "red";
          mistralFeedback.innerHTML = mistralResult === "valid" ? "&#10003;" : "&#10007;";
          mistralFeedback.style.color = mistralResult === "valid" ? "green" : "red";
          anthropicFeedback.innerHTML = anthropicResult === "valid" ? "&#10003;" : "&#10007;";
          anthropicFeedback.style.color = anthropicResult === "valid" ? "green" : "red";
          geminiFeedback.innerHTML = geminiResult === "valid" ? "&#10003;" : "&#10007;";
          geminiFeedback.style.color = geminiResult === "valid" ? "green" : "red";
          deepseekFeedback.innerHTML = deepseekResult === "valid" ? "&#10003;" : "&#10007;";
          deepseekFeedback.style.color = deepseekResult === "valid" ? "green" : "red";
          grokFeedback.innerHTML = grokResult === "valid" ? "&#10003;" : "&#10007;";
          grokFeedback.style.color = grokResult === "valid" ? "green" : "red";
          exaFeedback.innerHTML = exaResult === "valid" ? "&#10003;" : "&#10007;";
          exaFeedback.style.color = exaResult === "valid" ? "green" : "red";
        } catch (error) {
          console.error("Fehler beim Testen der API Keys:", error);
          alert("Fehler beim Testen der API Keys: " + error.message);
        } finally {
          spinner.style.display = "none";
        }
      };
    });
</script>
<!-- Firebase-Code wird jetzt ausgelagert -->
<script type="module" src="/static/firebase.js"></script>
<!-- Login Modal -->
<div id="loginModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeLoginModal">&times;</span>
    <h2>Login</h2>
    <!-- Das Login-Formular hat autocomplete="on" -->
    <form id="loginForm" autocomplete="on">
      <p style="color: red;">
        Important: Only one e-mail can be registered ‚Äì check carefully!
      </p>
      <input type="email" id="loginEmail" name="email" placeholder="Email" autocomplete="username">
      <input type="password" id="loginPassword" name="password" placeholder="Password" autocomplete="current-password">
      <button type="button" id="loginButton">Log in</button>
      <div id="loginError" class="error-message"></div><br/>
      <!-- Neuer Registrierungs-Button -->
      <button type="button" id="registerButton">Register</button>
      <div id="registerError" class="error-message"></div><br/>
      <a href="#" id="forgotPasswordButton">Forgot Password?</a>
    </form>
  </div>
</div>
<div id="disclaimerPopup" class="popup">
  <p>Currently usable with ChatGPT, Gemini and Exa. Soon also with other models!</p>
</div>
<div id="popupContainer">
  <!-- Modal zum Editieren des Systemprompts -->
  <div id="systemPromptModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span id="closeSystemPromptModal" class="close">&times;</span>
      <h2>Edit System Prompt</h2>
      <p>When empty, default is applied.</p>
      <textarea id="systemPromptInput" rows="4" style="width:100%;"></textarea>
      <button id="saveSystemPromptBtn">Save</button>
    </div>
  </div>
</div>
<!-- Hilfebutton (z.B. in der unteren rechten Ecke) -->
<button id="helpButton" class="help-button" title="Hilfe & Erkl√§rung">
  &#63;
</button>
<!-- FAQ Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content faq-modal">
    <span class="close" id="closeHelpModal">&times;</span>
    <div class="faq-header">
      <h2>FAQ & Quick Start</h2>
    </div>
    <div class="faq-body">
      <div class="faq-intro">
        <p>
          <strong>What is consens.io?</strong><br>
          consens.io instantly queries multiple leading AI models, creating a unified "consensus" answer. It also integrates real-time web search for accurate, up-to-date results.
        </p>
        <p>
          <strong>Benefits:</strong><br>
          ‚úì Reliable consensus answers<br>
          ‚úì Real-time web search<br>
          ‚úì Easy query bookmarking
        </p>
      </div>

      <div class="faq-item">
        <h3><span class="faq-number">1.</span> ü§ñ What is Auto Consensus? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          Auto Consensus automatically combines and compares answers from multiple AI models, highlighting differences, correcting errors, and providing a reliable final response.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">2.</span> üîò What is the Consensus Button? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          The Consensus Button generates a unified answer by merging responses from selected models. You can include (‚úÖ) or exclude (‚ùå) specific model outputs before clicking the button. It ensures that only trusted answers influence the final result.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">3.</span> üß† What is the Consensus Model? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          The Consensus Model is a special AI that processes and synthesizes responses from other models. It analyzes agreement, corrects inconsistencies, and creates a coherent final answer based on the selected responses.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">4.</span> üß© What are Differences? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          Differences highlight conflicting or unique parts across model responses. This lets you quickly spot where models disagree or contribute distinct perspectives‚Äîhelping you make informed decisions before generating a consensus.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">5.</span> üåê What is Web Search? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          Web Search sends your query to GPT and Gemini with real-time internet access, delivering current and accurate results directly within consens.io.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">6.</span> ‚úÖ‚ùå What are the checkmarks and crosses? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          The checkmark (‚úÖ) selects an answer to be included in the consensus generation. The cross (‚ùå) excludes an answer from influencing the final consensus.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">7.</span> üîë When do I need to enter API keys? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          You only need to enter your own API keys if you're not logged in or wish to use your personal model access.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">8.</span> üß† Which AI models are available? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          consens.io provides access to top-tier LLMs including OpenAI, Mistral, Anthropic, Gemini, and more.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">9.</span> üìå How do Bookmarks & Leaderboards work? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          Logged-in users can bookmark queries for future reference, and view popular queries on leaderboards, comparing their results with other users.
        </p>
      </div>

      <div class="faq-item">
        <h3><span class="faq-number">10.</span> üî¢ How many queries can I make? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          Free users can make up to 25 AI-powered queries. This includes consensus generations, web searches, and direct model queries. You can track your remaining quota in the sidebar.
        </p>
      </div>
      
      <div class="faq-item">
        <h3><span class="faq-number">11.</span> üí∏ Why are the first 25 queries free? <span class="faq-toggle-icon">Ôºã</span></h3>
        <p>
          We want you to explore consens.io with no commitment. The 25 free queries let you test the platform, compare models, and experience consensus answers‚Äîall without needing to provide payment information.
        </p>
      </div>      

    </div>
  </div>
</div>
</body>
</html>