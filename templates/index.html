<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>consens.io</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.png" type="image/x-icon">
  <!-- F√ºge dies im <head> hinzu -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Optional f√ºr Sicherheit: -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <script>
    window.FIREBASE_CONFIG = {
      apiKey: "{{ firebase_api_key }}",
      authDomain: "{{ firebase_auth_domain }}",
      projectId: "{{ firebase_project_id }}",
      storageBucket: "{{ firebase_storage_bucket }}",
      messagingSenderId: "{{ firebase_messaging_sender_id }}",
      appId: "{{ firebase_app_id }}"
    };
  </script>
</head>
<body>
<!-- Marketing Popup -->
<div id="marketingPopup" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Welcome to <span class="highlight">consens.io</span></h2>
    <p class="subheading">
      <span style="background-color: rgba(255,215,0,0.4); padding: 0 5px;">
        Don't ask just any AI.<br>
        Ask all of them.
      </span>
    </p>
    <div class="benefits">
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Model Comparison:</strong>
        <span>Get responses from multiple AI models simultaneously.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Transparency:</strong>
        <span>Recognize differences and similarities at a glance.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">‚úî</span>
        <strong>Flexible usage:</strong>
        <span>Use your own API keys or test directly for free.</span>
      </div>
    </div>
    <p class="cta-text">Log in & get started immediately ‚Äì free.</p>
    <button id="startNowButton" class="cta-button">Get started</button>
  </div>
</div>
  <header class="top-bar">
    <!-- Sidebar Toggle Button -->
    <button id="toggleSidebarButton" class="sidebar-toggle collapse-btn">
      <span class="burger-icon">&#9776;</span>
    </button>
    <!-- Logo und Titel -->
    <div class="top-bar-logo">
      <img src="/static/favicon.png" alt="Favicon" class="top-bar-favicon">
      <span class="top-bar-title">consens.io</span>
    </div>
    <!-- Container f√ºr rechte Elemente -->
    <div class="top-bar-right">
      <div id="loginContainer" class="login-text">Log in and use for free</div>
      <div class="mode-switch">
        <label class="switch">
          <input type="checkbox" id="modeToggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </header>
   
  <br/><br/><br/>
<!-- Sidebar f√ºr API Keys -->
<div class="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-header">
      <h2>
        Endpoints
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Enter your own API keys ‚Äì only necessary without login or when your quota is exhausted.</span>
        </span>
      </h2>
      <button id="toggleApiTest" onclick="toggleApiTest()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="apiTestArea" class="api-test-area">
      <div class="api-key-group">
        <label for="openaiKey">OpenAI API Key <span id="openaiFeedback" class="feedback"></span></label>
        <input type="password" id="openaiKey" placeholder="Your OpenAI Key">
      </div>
      <div class="api-key-group">
        <label for="mistralKey">Mistral API Key <span id="mistralFeedback" class="feedback"></span></label>
        <input type="password" id="mistralKey" placeholder="Your Mistral Key">
      </div>
      <div class="api-key-group">
        <label for="anthropicKey">Anthropic API Key <span id="anthropicFeedback" class="feedback"></span></label>
        <input type="password" id="anthropicKey" placeholder="Your Anthropic Key">
      </div>
      <div class="api-key-group">
        <label for="geminiKey">Google API Key <span id="geminiFeedback" class="feedback"></span></label>
        <input type="password" id="geminiKey" placeholder="Your Gemini Key">
      </div>
      <div class="api-key-group">
        <label for="deepseekKey">DeepSeek API Key <span id="deepseekFeedback" class="feedback"></span></label>
        <input type="password" id="deepseekKey" placeholder="Your DeepSeek Key">
      </div>
      <div class="api-key-group">
        <label for="grokKey">Grok API Key <span id="grokFeedback" class="feedback"></span></label>
        <input type="password" id="grokKey" placeholder="Your Grok Key">
      </div>      
      <div class="sidebar-tooltip">
        <button onclick="testAllKeys()">
          Save/Test all APIs 
          <span id="apiSpinner" class="spinner" style="display: none;"></span>
        </button>
        <div class="sidebar-tooltiptext">~1 min.</div>
      </div>      
    </div>
    <div id="usageOptions">
      <label for="useOwnKeysSwitch" class="custom-checkbox-label">
        Use your own API keys
        <input type="checkbox" id="useOwnKeysSwitch">
      </label>
      <span id="freeUsageDisplay">Free requests: ...</span>
    </div>      

    <!-- Trennstrich zwischen API Keys und Modelle -->
    <div class="sidebar-separator"></div>

    <!-- Verwendete Modelle (einklappbar) -->
    <div class="sidebar-header">
      <h2>
        Models
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Choose the models you want to use.</span>
        </span>
      </h2>
      <button id="toggleModelSelection" onclick="toggleModelSelection()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="modelSelectionArea" class="model-selection">
      <label for="selectOpenAI">
        <input type="checkbox" id="selectOpenAI" checked> OpenAI
      </label>
      <label for="selectMistral">
        <input type="checkbox" id="selectMistral" checked> Mistral
      </label>
      <label for="selectClaude">
        <input type="checkbox" id="selectClaude" checked> Anthropic Claude
      </label>
      <label for="selectGemini">
        <input type="checkbox" id="selectGemini" checked> Google Gemini
      </label>
      <label for="selectDeepSeek">
        <input type="checkbox" id="selectDeepSeek" checked> DeepSeek
      </label>
      <label for="selectGrok">
        <input type="checkbox" id="selectGrok" checked> Grok
      </label>      
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <!-- Leaderboard -->
    <div class="sidebar-header">
      <h2>
        Leaderboard 
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Displays the user leaderboard based on their results.</span>
        </span>
      </h2>
      <button id="toggleLeaderboard" onclick="toggleLeaderboard()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="leaderboardContentContainer" class="hidden">
      <div id="leaderboardContent"></div>
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <div class="sidebar-section">
      <h2>Bookmarks
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">All your chats if you are logged in.</span>
        </span>
      </h2>
      <div id="bookmarksContainer"></div>
    </div>
  </div>
  <!-- Neuer Abschnitt in der Sidebar f√ºr Einstellungen -->
  <div class="sidebar-settings">
    <button id="editSystemPromptBtn" title="Settings">
      <span class="settings-icon">‚öôÔ∏è</span>
      <span class="settings-label">Settings</span>
    </button>
  </div>
</div>

  <!-- Mode-Switch in der oberen rechten Ecke -->
  <div class="mode-switch">
    <label class="switch">
      <input type="checkbox" id="modeToggle">
      <span class="slider"></span>
    </label>
  </div>

  <div class="container">
    <div class="input-section">
      <div class="chat-input-container" style="position: relative;">
        <textarea class="input-field" id="questionInput" placeholder="Enter your question"></textarea>
        <button id="toggleAllButton" onclick="toggleAllResponses()" title="Collapse or expand all answers">
          <span class="toggle-visual"></span>
        </button>
        <!-- Container f√ºr beide Schalter -->
        <div class="consensus-switch-container" style="position: absolute; bottom: 10px; left: 10px; display: flex; align-items: center; gap: 20px;">
          <!-- Auto-Konsens-Switch -->
          <div class="auto-consensus">
            <label class="switch">
              <input type="checkbox" id="autoConsensusToggle">
              <span class="slider"></span>
            </label>
            <span class="auto-consensus-label">Auto Consensus</span>
          </div>
          <!-- Search Mode Switch, standardm√§√üig leicht ausgegraut -->
          <div class="search-mode">
            <label class="switch">
              <input type="checkbox" id="searchModeToggle">
              <span class="slider"></span>
            </label>
            <span class="search-mode-label">Search Mode</span>
            <!-- Disclaimer, der nur beim Aktivieren angezeigt wird -->
            <span id="searchDisclaimer" class="search-disclaimer" style="display: none; font-size: 0.8em; margin-left: 5px;">
              Currently only available with ChatGPT and Gemini, soon also usable with other models!
            </span>
          </div>
        </div>
        <button class="button" id="sendButton" onclick="sendQuestion()">
          <!-- SVG-Icon f√ºr einen Pfeil, der nach unten zeigt -->
          <svg class="input-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="response-section" style="position: relative;">
      <!-- Antwort OpenAI -->
      <div class="response-box" id="openaiResponse" data-model="OpenAI">
        <h2>
          <span class="title">Response from ChatGPT <small>(GPT-4o)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('openaiResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('openaiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('openaiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Mistral -->
      <div class="response-box" id="mistralResponse" data-model="Mistral">
        <h2>
          <span class="title">Response from Mistral <small>(mistral-large-latest)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('mistralResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('mistralResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('mistralResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Anthropic Claude -->
      <div class="response-box" id="claudeResponse" data-model="Anthropic">
        <h2>
          <span class="title">Response from Claude <small>(claude-3-5-sonnet)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('claudeResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('claudeResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('claudeResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Google Gemini -->
      <div class="response-box" id="geminiResponse" data-model="Google Gemini">
        <h2>
          <span class="title">Response from Gemini <small>(gemini-pro)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('geminiResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('geminiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('geminiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort DeepSeek -->
      <div class="response-box" id="deepseekResponse" data-model="DeepSeek">
        <h2>
          <span class="title">Response from DeepSeek <small>(deepseek-chat)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('deepseekResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('deepseekResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('deepseekResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Grok -->
      <div class="response-box" id="grokResponse" data-model="Grok">
        <h2>
          <span class="title">Response from Grok <small>(grok-2)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('grokResponse')" title="Mark as best answer">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('grokResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('grokResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>     
    </div>
    
    <!-- Konsens-Section -->
    <div class="consensus-section">
      <div class="consensus-wrapper">
        <!-- Konsens-Kontrolle: Schalter, Button und Dropdown wie gehabt -->
        <div class="consensus-controls">
          <!-- Tooltip-Wrapper um den Button -->
          <div class="tooltip">
            <button id="consensusButton" onclick="getConsensus()">Generate Consensus Answer</button>
            <!-- Das Hover-Feld mit weiteren Infos -->
            <div class="tooltiptext">
              Combine four responses into a final, consistent consensus by reconciling contradictions and errors.
            </div>
          </div>
          <div class="consensus-model">
            <label for="consensusModelDropdown" class="consensus-label">Consensus Model:</label>
            <div class="select-wrapper">
              <select id="consensusModelDropdown">
                <option value="OpenAI">GPT‚Äë4o</option>
                <option value="Anthropic">claude-3-5</option>
                <option value="Mistral">mistral-large-latest</option>
                <option value="Google Gemini">gemini-pro</option>
                <option value="DeepSeek">deepseek-chat</option>
                <option value="Grok">grok-chat</option>
              </select>
            </div>
          </div>
        </div>
        <!-- Konsens-Box mit zwei nebeneinanderliegenden Bereichen -->
        <div class="consensus-box" id="consensusResponse">
          <!-- Linker Bereich: Konsens-Antwort (80%) -->
          <div class="consensus-main">
            <h2>Consensus Answer</h2>
            <p></p>
          </div>
          <!-- Rechter Bereich: Unterschiede (20%) -->
          <div class="consensus-differences">
            <h2>Differences</h2>
            <p></p>
          </div>
        </div>
      </div>
    </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // --------------------------
      // Dark/Light Mode Initialisierung
      // --------------------------
      const modeToggle = document.getElementById("modeToggle");

      function applyTheme(theme) {
        if (theme === "dark") {
          document.body.classList.add("dark-mode");
          modeToggle.checked = true;
        } else {
          document.body.classList.remove("dark-mode");
          modeToggle.checked = false;
        }
      }

      // Lese gespeicherten Wert aus; wenn keiner vorhanden, verwende die Systempr√§ferenz:
      let storedTheme = localStorage.getItem("theme");
      if (!storedTheme) {
        storedTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        localStorage.setItem("theme", storedTheme);
      }
      applyTheme(storedTheme);

      // Schalte den Dark Mode um und speichere die Auswahl:
      modeToggle.addEventListener("change", function() {
        const newTheme = this.checked ? "dark" : "light";
        localStorage.setItem("theme", newTheme);
        applyTheme(newTheme);
      });
      
      // --------------------------
      // Marketing Popup Initialisierung
      // --------------------------
      // √úberpr√ºfen, ob das Popup schon angezeigt wurde

      const FREE_USAGE_LIMIT = 25;

      if (!localStorage.getItem("marketingPopupShown")) {
        document.getElementById("marketingPopup").style.display = "block";
        document.body.classList.add("modal-open");
      }

      // Popup schlie√üen, wenn auf das "x" geklickt wird
      document.querySelector("#marketingPopup .close").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        document.body.classList.remove("modal-open");
        localStorage.setItem("marketingPopupShown", "true");
      });

      // Popup schlie√üen, wenn der "Jetzt starten"-Button geklickt wird
      document.getElementById("startNowButton").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        localStorage.setItem("marketingPopupShown", "true");
      });

      document.addEventListener("click", function(event) {
        const sidebar = document.querySelector('.sidebar');
        const burgerButton = document.querySelector('.sidebar-toggle');
        
        // Nur auf kleinen Displays
        if (window.innerWidth <= 1400 && sidebar.classList.contains("active")) {
          // Wenn der Klick weder innerhalb der Sidebar noch auf dem Burger-Button erfolgt
          if (!sidebar.contains(event.target) && !event.target.closest('.sidebar-toggle')) {
            sidebar.classList.remove("active");
          }
        }
      });

      // Beispiel f√ºr das Setzen des systemPrompt-Wertes, falls noch nicht gesetzt:
      const defaultPrompt = "Please respond briefly and precisely, focusing only on the essentials.";
      if (!localStorage.getItem("systemPrompt")) {
        localStorage.setItem("systemPrompt", defaultPrompt);
      }

      // √ñffnen des Modals beim Klick auf das Zahnrad
      document.getElementById("editSystemPromptBtn").addEventListener("click", function() {
        const modal = document.getElementById("systemPromptModal");
        const textarea = document.getElementById("systemPromptInput");
        textarea.value = localStorage.getItem("systemPrompt");
        modal.style.display = "block";
      });

      // Schlie√üen des Modals
      document.getElementById("closeSystemPromptModal").addEventListener("click", function() {
        document.getElementById("systemPromptModal").style.display = "none";
      });

      // Speichern des neuen Prompts
      document.getElementById("saveSystemPromptBtn").addEventListener("click", function() {
        const newPrompt = document.getElementById("systemPromptInput").value.trim();
        localStorage.setItem("systemPrompt", newPrompt); // Speichert auch leere Strings!
        document.getElementById("systemPromptModal").style.display = "none";
      });

      const freeDisplay = document.getElementById("freeUsageDisplay");
      const idToken = localStorage.getItem("id_token");
      if (idToken && freeDisplay) {
        fetch("/usage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ id_token: idToken })
        })
          .then(response => response.json())
          .then(data => {
            freeDisplay.innerText = "Free requests:\u00A0" + data.remaining + " / " + 25;
          })
          .catch(err => console.error("Error when retrieving the quota:", err));
      }
      // --------------------------
      // Event-Listener f√ºr Eingabefelder und Buttons
      // --------------------------
    
      // Frage per Enter (ohne Zeilenumbruch) absenden
      document.getElementById("questionInput").addEventListener("keydown", function(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendQuestion();
        }
      });
    
      document.getElementById("toggleSidebarButton").addEventListener("click", function() {
        const sidebar = document.querySelector(".sidebar");
        sidebar.classList.toggle("collapsed");
      });

      document.getElementById('toggleSidebarButton').addEventListener('click', function() {
        const sidebar = document.querySelector('.sidebar');
        sidebar.classList.toggle('active');
      });
    
      // Fenstergr√∂√üe pr√ºfen ‚Äì wenn <1024px, Sidebar einklappen
      function checkWindowSize() {
        const sidebar = document.querySelector(".sidebar");
        if (window.innerWidth < 1024) {
          sidebar.classList.add("collapsed");
        } else {
          sidebar.classList.remove("collapsed");
        }
        updateToggleButton();
      }
      window.addEventListener("resize", checkWindowSize);
      checkWindowSize(); // Initial
    
      // Aktualisiert den Pfeil des Sidebar-Toggle-Buttons
      function updateToggleButton() {
        const sidebar = document.querySelector(".sidebar");
        const newText = sidebar.classList.contains("collapsed") ? "‚ñ∫" : "‚óÑ";
        const arrow = document.querySelector(".sidebar-toggle .arrow");
        if (arrow) {
          arrow.textContent = newText;
        }
      }

      // Extrahiert aus dem Differences-Text den BestModel-Wert
      function parseBestModel(differencesText) {
        const regex = /BestModel:\s*(.*)/i;
        const match = differencesText.match(regex);
        return match ? match[1].trim() : null;
      }

      // Funktion, um das Popup anzuzeigen
      function showPopup(message) {
        const popup = document.createElement('div');
        popup.className = 'explanation-popup';
        popup.innerText = message;
        document.body.appendChild(popup);
        
        setTimeout(() => {
          popup.style.opacity = '1';
        }, 100);
        
        setTimeout(() => {
          popup.style.opacity = '0';
          setTimeout(() => {
            popup.remove();
          }, 300);
        }, 3000);
      }
    
      // --------------------------
      // Globale Funktionen (f√ºr Inline-Aufrufe)
      // --------------------------

      window.toggleBest = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("excluded")) return;
        // Nur Popup anzeigen, wenn die Antwort nicht bereits als "best" markiert ist
        if (!box.classList.contains("best")) {
          showPopup("You mark this answer as the best answer. This way it will be highlighted and given special attention in the consensus.");
        }
        if (box.classList.contains("best")) {
          box.classList.remove("best");
        } else {
          document.querySelectorAll(".response-box").forEach(b => b.classList.remove("best"));
          box.classList.add("best");
          const model = box.getAttribute("data-model");
          // Direkter Aufruf zur Firebase-Funktion:
          recordModelVote(model, "best");
        }
      };

      // API Testbereich umschalten (f√ºr den Pfeil in der API Keys Section)
      window.toggleApiTest = function() {
        const area = document.getElementById("apiTestArea");
        const button = document.getElementById("toggleApiTest");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };
    
      // Modelle-Auswahl umschalten (f√ºr den Pfeil in der Modelle Section)
      window.toggleModelSelection = function() {
        const area = document.getElementById("modelSelectionArea");
        const button = document.getElementById("toggleModelSelection");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };

      window.toggleAllResponses = function() {
        const responses = document.querySelectorAll('.response-box');
        let shouldCollapse = false;
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          if (content && !content.classList.contains('collapsed')) {
            shouldCollapse = true;
          }
        });
        
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          const arrow = box.querySelector('.collapse-btn .arrow');
          if (shouldCollapse) {
            if (content && !content.classList.contains('collapsed')) {
              content.classList.add('collapsed');
            }
            if (arrow && !arrow.classList.contains('rotated')) {
              arrow.classList.add('rotated');
            }
          } else {
            if (content && content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
            }
            if (arrow && arrow.classList.contains('rotated')) {
              arrow.classList.remove('rotated');
            }
          }
        });
      };
    
      // Collapse/Expand einer Antwort-Box
      window.toggleCollapse = function(responseId) {
        const responseBox = document.getElementById(responseId);
        const content = responseBox.querySelector(".collapsible-content");
        const arrow = responseBox.querySelector(".collapse-btn .arrow");
        content.classList.toggle("collapsed");
        arrow.classList.toggle("rotated");
      };
    
      // Exclude/Include einer Antwort-Box (falls nicht als "best" markiert)
      window.toggleExclude = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("best")) return;
        // Nur Popup anzeigen, wenn die Antwort nicht bereits ausgeschlossen ist
        if (!box.classList.contains("excluded")) {
          showPopup("You have excluded this answer. It will be removed from the view and not included in the consensus.");
        }
        box.classList.toggle("excluded");
      };
    
      let leaderboardInterval; // Variable zum Speichern des Interval-IDs

      window.toggleLeaderboard = function() {
        const container = document.getElementById("leaderboardContentContainer");
        const arrow = document.getElementById("toggleLeaderboard").querySelector(".arrow");
        container.classList.toggle("hidden");
        arrow.classList.toggle("rotated");
      };

      // Globale Variable
      let consensusGenerated = false;
      document.getElementById("consensusButton").disabled = true;

      // Senden der Frage an die aktiven Modelle
      window.sendQuestion = async function() {
        document.getElementById("sendButton").disabled = true;
        // Konsens-Button wieder aktivieren, bevor eine neue Anfrage gesendet wird.
        document.getElementById("consensusButton").disabled = false;
        const question = document.getElementById("questionInput").value;
        consensusGenerated = false;
        if (!question) {
          alert("Please enter a question.");
          return;
        }
        const spinnerHTML = '<span class="spinner"></span>';
        // Lese den benutzerdefinierten Systemprompt aus oder nutze den Standardwert
        const customSystemPrompt = localStorage.getItem("systemPrompt") || "Please respond briefly and precisely, focusing only on the essentials.";
        console.log("Using system prompt:", customSystemPrompt);
        
        // Beispiel f√ºr den Payload f√ºr OpenAI:
        const payload = {
          question: question,
          active_count: 1,
          search_mode: document.getElementById("searchModeToggle").checked,
          system_prompt: customSystemPrompt
        };

        // Konsens-Button deaktivieren, solange noch Antworten fehlen
        const consensusBtn = document.getElementById("consensusButton");
        consensusBtn.disabled = true;
        totalRequiredResponses = 0;

        const openaiBox = document.getElementById("openaiResponse");
        const mistralBox = document.getElementById("mistralResponse");
        const claudeBox = document.getElementById("claudeResponse");
        const geminiBox = document.getElementById("geminiResponse");
        const deepseekBox = document.getElementById("deepseekResponse");
        const grokBox = document.getElementById("grokResponse");

        // Z√§hle nur die Modelle, die nicht als "ausgeschlossen" markiert sind
        if (!openaiBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!mistralBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!claudeBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!geminiBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!deepseekBox.classList.contains("excluded")) totalRequiredResponses++;
        if (!grokBox.classList.contains("excluded")) totalRequiredResponses++;

        let activeModels = [];
        if (document.getElementById("selectOpenAI").checked) activeModels.push("OpenAI");
        if (document.getElementById("selectMistral").checked) activeModels.push("Mistral");
        if (document.getElementById("selectClaude").checked) activeModels.push("Anthropic");
        if (document.getElementById("selectGemini").checked) activeModels.push("Google Gemini");
        if (document.getElementById("selectDeepSeek").checked) activeModels.push("DeepSeek");
        if (document.getElementById("selectGrok").checked) activeModels.push("Grok");
    
        // Spinner in den jeweiligen Response-Boxen setzen
        if (activeModels.includes("OpenAI")) {
          document.getElementById("openaiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Mistral")) {
          document.getElementById("mistralResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Anthropic")) {
          document.getElementById("claudeResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Google Gemini")) {
          document.getElementById("geminiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("DeepSeek")) {
          document.getElementById("deepseekResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Grok")) {
          document.getElementById("grokResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (document.getElementById("autoConsensusToggle").checked) {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = spinnerHTML;
        } else {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = "";
        }
    
        // API Keys aus localStorage abrufen
        const openaiKey = localStorage.getItem("openaiKey") || "";
        const mistralKey = localStorage.getItem("mistralKey") || "";
        const anthropicKey = localStorage.getItem("anthropicKey") || "";
        const geminiKey = localStorage.getItem("geminiKey") || "";
        const deepseekKey = localStorage.getItem("deepseekKey") || "";
        const grokKey = localStorage.getItem("grokKey") || "";
    
        let responsesReceived = 0;
        const totalActive = activeModels.length;
        function checkAllResponses() {
          responsesReceived++;
          if (responsesReceived === totalActive) {
            // Sende-Button immer wieder freischalten
            document.getElementById("sendButton").disabled = false;
            
            if (document.getElementById("autoConsensusToggle").checked) {
              // Auto Consensus ist aktiviert: 
              // Den Consensus-Button vor√ºbergehend deaktivieren und
              // erst nach Abschluss der Konsensgenerierung wieder aktivieren.
              document.getElementById("consensusButton").disabled = true;
              getConsensus()
                .then(() => {
                  document.getElementById("consensusButton").disabled = false;
                })
                .catch((error) => {
                  console.error("Fehler bei der Konsensgenerierung:", error);
                  document.getElementById("consensusButton").disabled = false;
                });
            } else {
              // Auto Consensus nicht aktiviert ‚Äì beide Buttons direkt freigeben.
              document.getElementById("consensusButton").disabled = false;
            }
          }
        }

      // Hilfsfunktion, um einen leeren API Key zu pr√ºfen
      function validateUserKey(keyName) {
        const key = localStorage.getItem(keyName);
        return key && key.trim() !== "";
      }

      function addCopyButtons(container) {
        container.querySelectorAll('pre').forEach(function(pre) {
          // Falls bereits ein Copy-Button existiert, √ºberspringen
          if (pre.querySelector('.copy-btn')) return;
          
          var btn = document.createElement('button');
          // Verwende ein dezentes Clipboard-Symbol
          btn.textContent = 'üìã';
          btn.className = 'copy-btn';
          pre.appendChild(btn);
          
          btn.addEventListener('click', function() {
            // Falls ein <code> innerhalb des <pre> existiert, kopiere dessen innerText
            var codeElement = pre.querySelector('code');
            var codeText = codeElement ? codeElement.innerText : pre.innerText;
            navigator.clipboard.writeText(codeText).then(function() {
              btn.textContent = '‚úì';
              setTimeout(function() {
                btn.textContent = 'üìã';
              }, 2000);
            });
          });
        });
      }

      // Mache addCopyButtons global verf√ºgbar:
      window.addCopyButtons = addCopyButtons;

      // OpenAI
      if (activeModels.includes("OpenAI")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,  // Passe diesen Wert ggf. dynamisch an
          // Hier wird der neue Parameter hinzugef√ºgt:
          search_mode: document.getElementById("searchModeToggle").checked,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("openaiKey") || "";
          }
        } else {
          if (!validateUserKey("openaiKey")) {
            alert("Please enter a valid OpenAI API key.");
            return;
          }
          payload.api_key = localStorage.getItem("openaiKey");
        }

        fetch('/ask_openai', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("openaiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "OpenAI");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei OpenAI:", error);
            checkAllResponses();
          });
      }


      // Mistral
      if (activeModels.includes("Mistral")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("mistralKey") || "";
          }
        } else {
          if (!validateUserKey("mistralKey")) {
            alert("Please enter a valid Mistral API key.");
            return;
          }
          payload.api_key = localStorage.getItem("mistralKey");
        }

        fetch('/ask_mistral', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("mistralResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Mistral");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Mistral:", error);
            checkAllResponses();
          });
      }

      // Anthropic Claude
      if (activeModels.includes("Anthropic")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("anthropicKey") || "";
          }
        } else {
          if (!validateUserKey("anthropicKey")) {
            alert("Please enter a valid Anthropic API Key.");
            return;
          }
          payload.api_key = localStorage.getItem("anthropicKey");
        }

        fetch('/ask_claude', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("claudeResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Anthropic");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Anthropic:", error);
            checkAllResponses();
          });
      }

      // Google Gemini
      if (activeModels.includes("Google Gemini")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            active_count: 1,
            // Suche-Parameter hinzuf√ºgen:
            search_mode: document.getElementById("searchModeToggle").checked,
            system_prompt: customSystemPrompt
          };

          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("geminiKey") || "";
            }
          } else {
            if (!validateUserKey("geminiKey")) {
              alert("Please enter a valid Google Gemini API Key.");
              return;
            }
            payload.api_key = localStorage.getItem("geminiKey");
          }

          fetch('/ask_gemini', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("geminiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Gemini");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Error with Google Gemini:", error);
            checkAllResponses();
          });
      }

      // DeepSeek
      if (activeModels.includes("DeepSeek")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("deepseekKey") || "";
          }
        } else {
          if (!validateUserKey("deepseekKey")) {
            alert("Please enter a valid DeepSeek API key.");
            return;
          }
          payload.api_key = localStorage.getItem("deepseekKey");
        }

        fetch('/ask_deepseek', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("deepseekResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
              addCopyButtons(outputEl);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "DeepSeek");
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Free requests:" + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei DeepSeek:", error);
            checkAllResponses();
          });
      }

      // Grok
      if (activeModels.includes("Grok")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,
          system_prompt: customSystemPrompt
        };
        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("grokKey") || "";
          }
        } else {
          if (!validateUserKey("grokKey")) {
            alert("Please enter a valid Grok API key.");
            return;
          }
          payload.api_key = localStorage.getItem("grokKey");
        }
        fetch('/ask_grok', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
        .then(response => response.json())
        .then(data => {
          const outputEl = document.getElementById("grokResponse").querySelector(".collapsible-content");
          if (data.response) {
            outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            addCopyButtons(outputEl);
            if (auth.currentUser) {
              saveBookmark(question, data.response, "Grok");
            }
          } else if (data.error) {
            outputEl.innerText = data.error;
          } else {
            outputEl.innerText = "Please log in or store your own API keys.";
          }
          if (data.free_usage_remaining !== undefined) {
            document.getElementById("freeUsageDisplay").innerText =
              "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
          }
          checkAllResponses();
        })
        .catch(error => {
          console.error("Fehler bei Grok:", error);
          checkAllResponses();
        });
      }
    };
    
      // Modelle (Checkboxen) ein-/ausschalten
      window.toggleModel = function(responseId, isChecked) {
        const box = document.getElementById(responseId);
        if (!isChecked) {
          box.classList.add("excluded");
        } else {
          box.classList.remove("excluded");
        }
      };
      document.getElementById("selectOpenAI").addEventListener("change", function() {
        toggleModel("openaiResponse", this.checked);
      });
      document.getElementById("selectMistral").addEventListener("change", function() {
        toggleModel("mistralResponse", this.checked);
      });
      document.getElementById("selectClaude").addEventListener("change", function() {
        toggleModel("claudeResponse", this.checked);
      });
      document.getElementById("selectGemini").addEventListener("change", function() {
        toggleModel("geminiResponse", this.checked);
      });
      document.getElementById("selectDeepSeek").addEventListener("change", function() {
        toggleModel("deepseekResponse", this.checked);
      });
      document.getElementById("selectGrok").addEventListener("change", function() {
        toggleModel("grokResponse", this.checked);
      });
    
      // Erneut API Keys in Felder schreiben (falls ben√∂tigt)
      ["openaiKey", "mistralKey", "anthropicKey", "geminiKey", "deepseekKey", "grokKey"].forEach(function(key) {
        const stored = localStorage.getItem(key);
        if (stored) {
          document.getElementById(key).value = stored;
        }
      });

    // Search Mode Toggle: Modelle automatisch anpassen, wenn aktiviert
    const searchModeToggle = document.getElementById("searchModeToggle");
    const searchDisclaimer = document.getElementById("searchDisclaimer");

    function showDisclaimerPopup() {
      const popup = document.getElementById('disclaimerPopup');
      popup.classList.add('show');
      // Popup nach 3 Sekunden wieder ausblenden
      setTimeout(() => {
        popup.classList.remove('show');
      }, 5000);
    }

    searchModeToggle.addEventListener("change", function() {
      const isSearchMode = this.checked;

      // Hole die Checkboxen der Modelle
      const openaiCheckbox = document.getElementById("selectOpenAI");
      const mistralCheckbox = document.getElementById("selectMistral");
      const claudeCheckbox = document.getElementById("selectClaude");
      const geminiCheckbox = document.getElementById("selectGemini");
      const deepseekCheckbox = document.getElementById("selectDeepSeek");
      const grokCheckbox = document.getElementById("selectGrok");

      // Hole das Konsens-Dropdown
      const consensusDropdown = document.getElementById("consensusModelDropdown");

      if (isSearchMode) {
        // Zeige den Inline-Disclaimer zun√§chst an
        searchDisclaimer.style.display = "inline-block";
        
        // Nur OpenAI (ChatGPT) unterst√ºtzt aktuell den Search Mode.
        // Deaktiviere und deaktiviere alle anderen Modelle.
        mistralCheckbox.checked = false;
        claudeCheckbox.checked = false;
        deepseekCheckbox.checked = false;
        grokCheckbox.checked = false;

        mistralCheckbox.disabled = true;
        claudeCheckbox.disabled = true;
        deepseekCheckbox.disabled = true;
        grokCheckbox.disabled = true;

        // Optional: Setze die zugeh√∂rigen Response-Boxen auf "ausgeschlossen"
        toggleModel("mistralResponse", false);
        toggleModel("claudeResponse", false);
        toggleModel("deepseekResponse", false);
        toggleModel("grokResponse", false);

        // Setze das Konsensmodell automatisch auf OpenAI und deaktiviere die Auswahl
        consensusDropdown.value = "OpenAI";
        consensusDropdown.disabled = true;

        // Auf kleinen Bildschirmen: Popup anzeigen statt Inline-Disclaimer
        if (window.innerWidth < 1400) {
          showDisclaimerPopup();
          searchDisclaimer.style.display = "none";
        }
      } else {
        // Schalte den Inline-Disclaimer aus
        searchDisclaimer.style.display = "none";

        // Reaktiviere alle Modelle, wenn der Search Mode ausgeschaltet wird.
        mistralCheckbox.disabled = false;
        claudeCheckbox.disabled = false;
        deepseekCheckbox.disabled = false;
        grokCheckbox.disabled = false;

        // Setze die Checkboxen wieder auf "angew√§hlt"
        mistralCheckbox.checked = true;
        claudeCheckbox.checked = true;
        deepseekCheckbox.checked = true;
        grokCheckbox.checked = true;

        // Aktualisiere die zugeh√∂rigen Response-Boxen als "nicht ausgeschlossen"
        toggleModel("mistralResponse", true);
        toggleModel("claudeResponse", true);
        toggleModel("geminiResponse", true);
        toggleModel("deepseekResponse", true);
        toggleModel("grokResponse", true);

        // Reaktiviere das Konsens-Dropdown
        consensusDropdown.disabled = false;
      }
    });
    
      // Globale Variable, um die letzte verarbeitete Frage zu speichern.
      let lastQuestion = "";

      window.getConsensus = async function() {
        const question = document.getElementById("questionInput").value.trim();
          // Status, ob eigene API Keys genutzt werden sollen
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        let searchMode = document.getElementById("searchModeToggle").checked;
        
        // Nur im Gratis-Modus id_token abrufen
        const id_token = useOwnKeys ? null : localStorage.getItem("id_token");

        // Wenn die Frage neu oder ge√§ndert ist, werden Firebase-Votes aktualisiert.
        if (question !== lastQuestion) {
          // F√ºr jedes Modell pr√ºfen, ob es als "best" markiert ist.
          if (document.getElementById("openaiResponse").classList.contains("best")) {
            recordModelVote("OpenAI", "best");
          }
          if (document.getElementById("mistralResponse").classList.contains("best")) {
            recordModelVote("Mistral", "best");
          }
          if (document.getElementById("claudeResponse").classList.contains("best")) {
            recordModelVote("Anthropic", "best");
          }
          if (document.getElementById("geminiResponse").classList.contains("best")) {
            recordModelVote("Gemini", "best");
          }
          if (document.getElementById("deepseekResponse").classList.contains("best")) {
            recordModelVote("DeepSeek", "best");
          }
          if (document.getElementById("grokResponse").classList.contains("best")) {
            recordModelVote("Grok", "best");
          }

          // Ebenso f√ºr "excluded" (sofern du das separat erfassen m√∂chtest).
          if (document.getElementById("openaiResponse").classList.contains("excluded")) {
            recordModelVote("OpenAI", "exclude");
          }
          if (document.getElementById("mistralResponse").classList.contains("excluded")) {
            recordModelVote("Mistral", "exclude");
          }
          if (document.getElementById("claudeResponse").classList.contains("excluded")) {
            recordModelVote("Anthropic", "exclude");
          }
          if (document.getElementById("geminiResponse").classList.contains("excluded")) {
            recordModelVote("Gemini", "exclude");
          }
          if (document.getElementById("deepseekResponse").classList.contains("excluded")) {
            recordModelVote("DeepSeek", "exclude");
          }
          if (document.getElementById("grokResponse").classList.contains("excluded")) {
            recordModelVote("Grok", "exclude");
          }

          // Aktualisiere die letzte verarbeitete Frage.
          lastQuestion = question;
        }

        // Setze den Konsens-Bereich (Spinner etc.) und rufe anschlie√üend deinen Konsens-Endpunkt auf.
        const consensusDiv = document.getElementById("consensusResponse");
        const mainSpinner = '<span class="spinner"></span>';
        const diffSpinner = '<span class="spinner"></span>';

        consensusDiv.querySelector(".consensus-main p").innerHTML = mainSpinner;
        consensusDiv.querySelector(".consensus-differences p").innerHTML = diffSpinner;

      const consensus_model = document.getElementById("consensusModelDropdown").value;

      // Hole die Antwort-Boxen
      const openaiBox = document.getElementById("openaiResponse");
      const mistralBox = document.getElementById("mistralResponse");
      const claudeBox = document.getElementById("claudeResponse");
      const geminiBox = document.getElementById("geminiResponse");
      const deepseekBox = document.getElementById("deepseekResponse");
      const grokBox = document.getElementById("grokResponse");

      // Lies die Antworten (trim f√ºr √ºberfl√ºssige Leerzeichen)
      const answer_openai = openaiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_mistral = mistralBox.querySelector(".collapsible-content").innerText.trim();
      const answer_claude = claudeBox.querySelector(".collapsible-content").innerText.trim();
      const answer_gemini = geminiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_deepseek = deepseekBox.querySelector(".collapsible-content").innerText.trim();
      const answer_grok = grokBox.querySelector(".collapsible-content").innerText.trim();

      // √úberpr√ºfe nur die Modelle, die nicht als "ausgeschlossen" markiert sind.
      if (
        !question ||
        !consensus_model ||
        (!openaiBox.classList.contains("excluded") && !answer_openai) ||
        (!mistralBox.classList.contains("excluded") && !answer_mistral) ||
        (!claudeBox.classList.contains("excluded") && !answer_claude) ||
        (!geminiBox.classList.contains("excluded") && !answer_gemini) ||
        (!deepseekBox.classList.contains("excluded") && !answer_deepseek) ||
        (!grokBox.classList.contains("excluded") && !answer_grok)
      ) {
        alert("Refresh the page. Please send a question first, retrieve all answers and select the consensus model.");
        return;
      }

      // Hole den best markierten Modus (falls vorhanden)
      const bestBox = document.querySelector(".response-box.best");
      let best_model = bestBox ? bestBox.getAttribute("data-model") : "";

      // Die √ºbrigen Parameter wie "excluded_models" werden wie bisher ermittelt
      const excludedModels = [];
      if (openaiBox.classList.contains("excluded")) {
        excludedModels.push(openaiBox.getAttribute("data-model"));
      }
      if (mistralBox.classList.contains("excluded")) {
        excludedModels.push(mistralBox.getAttribute("data-model"));
      }
      if (claudeBox.classList.contains("excluded")) {
        excludedModels.push(claudeBox.getAttribute("data-model"));
      }
      if (geminiBox.classList.contains("excluded")) {
        excludedModels.push(geminiBox.getAttribute("data-model"));
      }
      if (deepseekBox.classList.contains("excluded")) {
        excludedModels.push(deepseekBox.getAttribute("data-model"));
      }
      if (grokBox.classList.contains("excluded")) {
        excludedModels.push(grokBox.getAttribute("data-model"));
      }

      // Hole API Keys aus localStorage
      const openaiKey = localStorage.getItem("openaiKey") || "";
      const mistralKey = localStorage.getItem("mistralKey") || "";
      const anthropicKey = localStorage.getItem("anthropicKey") || "";
      const geminiKey = localStorage.getItem("geminiKey") || "";
      const deepseekKey= localStorage.getItem("deepseekKey") || "";
      const grokKey= localStorage.getItem("grokKey") || "";

      try {
        const response = await fetch("/consensus", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            id_token: id_token,
            useOwnKeys: useOwnKeys,
            question: question,
            search_mode: searchMode,
            answer_openai: answer_openai,
            answer_mistral: answer_mistral,
            answer_claude: answer_claude,
            answer_gemini: answer_gemini,
            answer_deepseek: answer_deepseek,
            answer_grok: answer_grok,
            best_model: best_model,
            consensus_model: consensus_model,
            excluded_models: excludedModels,
            openai_key: openaiKey,
            mistral_key: mistralKey,
            anthropic_key: anthropicKey,
            gemini_key: geminiKey,
            deepseek_key: deepseekKey,
            grok_key: grokKey,
            keepalive: true
          })
        });
        const data = await response.json();
        if (response.ok) {
          // Aktualisiere den Konsens-Bereich und den Unterschiede-Bereich
          consensusDiv.querySelector(".consensus-main p").innerHTML = marked.parse(data.consensus_response);
          consensusDiv.querySelector(".consensus-differences p").innerHTML = marked.parse(data.differences || "No differences found.");
          const consensusMainEl = consensusDiv.querySelector(".consensus-main p");
          consensusMainEl.innerHTML = marked.parse(data.consensus_response);
          addCopyButtons(consensusMainEl);

          if (auth.currentUser) {
            saveBookmarkConsensus(question, data.consensus_response, data.differences);
          }

          // Parse den BestModel-Wert aus den Unterschieden und aktualisiere das Leaderboard in Firebase
          const bestModelFromConsensus = parseBestModel(data.differences);
          if (bestModelFromConsensus) {
            recordModelVote(bestModelFromConsensus, "BestModel");
          }
        } else {
          consensusDiv.querySelector(".consensus-main p").innerText = "Error: " + data.detail;
          consensusDiv.querySelector(".consensus-differences p").innerText = "";
        }
      } catch (error) {
        console.error("Error fetching consensus:", error);
        consensusDiv.querySelector(".consensus-main p").innerText = "Error in the consensus calculation.";
        consensusDiv.querySelector(".consensus-differences p").innerText = "";
      }
    };
    
      // Testet die API Keys und aktualisiert das Feedback
      window.testAllKeys = async function() {
        const openaiKey = document.getElementById("openaiKey").value;
        const mistralKey = document.getElementById("mistralKey").value;
        const anthropicKey = document.getElementById("anthropicKey").value;
        const geminiKey = document.getElementById("geminiKey").value;
        const deepseekKey = document.getElementById("deepseekKey").value;
        const grokKey = document.getElementById("grokKey").value;
        localStorage.setItem("openaiKey", openaiKey);
        localStorage.setItem("mistralKey", mistralKey);
        localStorage.setItem("anthropicKey", anthropicKey);
        localStorage.setItem("geminiKey", geminiKey);
        localStorage.setItem("deepseekKey", deepseekKey);
        localStorage.setItem("grokKey", grokKey);
        const spinner = document.getElementById("apiSpinner");
        spinner.style.display = "inline-block";
        try {
          const response = await fetch("/check_keys", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              openai_key: openaiKey,
              mistral_key: mistralKey,
              anthropic_key: anthropicKey,
              gemini_key: geminiKey,
              deepseek_key: deepseekKey,
              grok_key: grokKey
            })
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText);
          }
          const data = await response.json();
          console.log("Response von /check_keys:", data);
          if (!data || !data.results) {
            throw new Error("The response does not contain a 'results' object. Response: " + JSON.stringify(data));
          }
          const openaiResult = data.results["OpenAI"];
          const mistralResult = data.results["Mistral"];
          const anthropicResult = data.results["Anthropic"];
          const geminiResult = data.results["Google Gemini"];
          const deepseekResult = data.results["DeepSeek"];
          const grokResult = data.results["Grok"];
          const openaiFeedback = document.getElementById("openaiFeedback");
          const mistralFeedback = document.getElementById("mistralFeedback");
          const anthropicFeedback = document.getElementById("anthropicFeedback");
          const geminiFeedback = document.getElementById("geminiFeedback");
          const deepseekFeedback = document.getElementById("deepseekFeedback");
          const grokFeedback = document.getElementById("grokFeedback");
          openaiFeedback.innerHTML = openaiResult === "valid" ? "&#10003;" : "&#10007;";
          openaiFeedback.style.color = openaiResult === "valid" ? "green" : "red";
          mistralFeedback.innerHTML = mistralResult === "valid" ? "&#10003;" : "&#10007;";
          mistralFeedback.style.color = mistralResult === "valid" ? "green" : "red";
          anthropicFeedback.innerHTML = anthropicResult === "valid" ? "&#10003;" : "&#10007;";
          anthropicFeedback.style.color = anthropicResult === "valid" ? "green" : "red";
          geminiFeedback.innerHTML = geminiResult === "valid" ? "&#10003;" : "&#10007;";
          geminiFeedback.style.color = geminiResult === "valid" ? "green" : "red";
          deepseekFeedback.innerHTML = deepseekResult === "valid" ? "&#10003;" : "&#10007;";
          deepseekFeedback.style.color = deepseekResult === "valid" ? "green" : "red";
          grokFeedback.innerHTML = grokResult === "valid" ? "&#10003;" : "&#10007;";
          grokFeedback.style.color = grokResult === "valid" ? "green" : "red";
        } catch (error) {
          console.error("Fehler beim Testen der API Keys:", error);
          alert("Fehler beim Testen der API Keys: " + error.message);
        } finally {
          spinner.style.display = "none";
        }
      };
    });
</script>
<!-- Firebase-Code wird jetzt ausgelagert -->
<script type="module" src="/static/firebase.js"></script>
<!-- Login Modal -->
<div id="loginModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeLoginModal">&times;</span>
    <h2>Login</h2>
    <!-- Das Login-Formular hat autocomplete="on" -->
    <form id="loginForm" autocomplete="on">
      <p style="color: red;">
        Important: Only one e-mail can be registered ‚Äì check carefully!
      </p>
      <input type="email" id="loginEmail" name="email" placeholder="Email" autocomplete="username">
      <input type="password" id="loginPassword" name="password" placeholder="Password" autocomplete="current-password">
      <button type="button" id="loginButton">Log in</button>
      <div id="loginError" class="error-message"></div><br/>
      <!-- Neuer Registrierungs-Button -->
      <button type="button" id="registerButton">Register</button>
      <div id="registerError" class="error-message"></div><br/>
      <a href="#" id="forgotPasswordButton">Forgot Password?</a>
    </form>
  </div>
</div>
<div id="disclaimerPopup" class="popup">
  <p>Currently only usable with ChatGPT and Gemini, soon also with other models!</p>
</div>
<div id="popupContainer"></div>
<!-- Modal zum Editieren des Systemprompts -->
<div id="systemPromptModal" class="modal" style="display:none;">
  <div class="modal-content">
    <span id="closeSystemPromptModal" class="close">&times;</span>
    <h2>Edit System Prompt</h2>
    <p>When empty, default is applied.</p>
    <textarea id="systemPromptInput" rows="4" style="width:100%;"></textarea>
    <button id="saveSystemPromptBtn">Save</button>
  </div>
</div>
</body>
</html>