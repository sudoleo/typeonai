<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>consens.io</title>
  <script>
    window.FIREBASE_CONFIG = {
      apiKey: "{{ firebase_api_key }}",
      authDomain: "{{ firebase_auth_domain }}",
      projectId: "{{ firebase_project_id }}",
      storageBucket: "{{ firebase_storage_bucket }}",
      messagingSenderId: "{{ firebase_messaging_sender_id }}",
      appId: "{{ firebase_app_id }}"
    };
  </script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.png" type="image/x-icon">
  <!-- Füge dies im <head> hinzu -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Optional für Sicherheit: -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <!-- Marked (Markdown -> HTML) -->
  <script src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"></script>
  <!-- DOMPurify (HTML Sanitizer) -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
  <!-- Firebase-Code wird jetzt ausgelagert -->
  <script type="module" src="/static/firebase.js"></script>
</head>
<body>
<!-- Marketing Popup -->
<div id="marketingPopup" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Welcome to <span class="highlight">consens.io</span></h2>
    <div class="benefits">
      <p class="benefits-note"><strong>All free & completely non‑binding</strong></p>
    
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Models:</strong>
        <span>25 free queries to multiple leading AI models.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Deep Think Mode:</strong>
        <span>12 free deep‑research queries for detailed insights.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Search:</strong>
        <span>Real‑time web search for accurate, up‑to‑date results.</span>
      </div>
    </div>    
    <p class="cta-text">Log in & get started immediately – free.</p>
    <button id="startNowButton" class="cta-button">Get started</button>
  </div>
</div>
<header class="top-bar">
  <!-- Sidebar Toggle Button -->
  <button id="toggleSidebarButton" class="sidebar-toggle collapse-btn">
    <span class="burger-icon">&#9776;</span>
  </button>

  <!-- Logo und Titel -->
  <div class="top-bar-logo">
    <a href="/" id="logoLink">
      <img src="/static/favicon.png" alt="Favicon" class="top-bar-favicon">
    </a>
    <span class="top-bar-title">consens.io</span>
  </div>

  <!-- Rechte Seite -->
  <div class="top-bar-right">
    <!-- Neuer About-Link -->
    <div id="loginContainer" class="login-text">Log in</div>
    <!-- Dünner vertikaler Strich -->
    <span class="top-bar-divider" aria-hidden="true"></span>
    <!-- Bisheriger Login-Text -->
    <a href="/about" class="top-bar-about">About us</a>
    <!-- Dark/Light Toggle -->
    <div class="mode-switch">
      <label class="switch">
        <input type="checkbox" id="modeToggle">
        <span class="slider"></span>
      </label>
    </div>
  </div>
</header>
   
 <br/><br/><br/> 
<!-- Sidebar für API Keys -->
<div class="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-header">
      <h2>
        Endpoints
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Enter your own API keys – only necessary without login or when your quota is exhausted.</span>
        </span>
      </h2>
      <button id="toggleApiTest" onclick="toggleApiTest()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="apiTestArea" class="api-test-area">
      <div class="api-key-group">
        <label for="openaiKey">OpenAI API Key <span id="openaiFeedback" class="feedback"></span></label>
        <input type="text" id="openaiKey" placeholder="Your OpenAI Key" autocomplete="off">
      </div>
      <div class="api-key-group">
        <label for="mistralKey">Mistral API Key <span id="mistralFeedback" class="feedback"></span></label>
        <input type="text" id="mistralKey" placeholder="Your Mistral Key" autocomplete="off">
      </div>
      <div class="api-key-group">
        <label for="anthropicKey">Anthropic API Key <span id="anthropicFeedback" class="feedback"></span></label>
        <input type="text" id="anthropicKey" placeholder="Your Anthropic Key" autocomplete="off">
      </div>
      <div class="api-key-group">
        <label for="geminiKey">Google API Key <span id="geminiFeedback" class="feedback"></span></label>
        <input type="text" id="geminiKey" placeholder="Your Gemini Key" autocomplete="off">
      </div>
      <div class="api-key-group">
        <label for="deepseekKey">DeepSeek API Key <span id="deepseekFeedback" class="feedback"></span></label>
        <input type="text" id="deepseekKey" placeholder="Your DeepSeek Key" autocomplete="off">
      </div>
      <div class="api-key-group">
        <label for="grokKey">Grok API Key <span id="grokFeedback" class="feedback"></span></label>
        <input type="text" id="grokKey" placeholder="Your Grok Key" autocomplete="off">
      </div>          
      <div class="sidebar-tooltip">
        <button onclick="testAllKeys()">
          Save/Test all APIs 
          <span id="apiSpinner" class="spinner" style="display: none;"></span>
        </button>
        <div class="sidebar-tooltiptext">~1 min.</div>
      </div>      
    </div>
    <div id="usageOptions">
      <label for="useOwnKeysSwitch" class="custom-checkbox-label">
        Use your own API keys
        <input type="checkbox" id="useOwnKeysSwitch">
      </label>
      <div id="usageDisplay">
        <span id="freeUsageDisplay">Free requests: ...</span><br>
        <span id="deepUsageDisplay">Deep Think: ...</span><br>
        <!-- Countdown-Timer -->
        <span id="countdownDisplay"></span>
      </div>
    </div>      

    <!-- Trennstrich zwischen API Keys und Modelle -->
    <div class="sidebar-separator"></div>

    <!-- Verwendete Modelle (einklappbar) -->
    <div class="sidebar-header">
      <h2>
        Models
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Choose the models you want to use.</span>
        </span>
      </h2>
      <button id="toggleModelSelection" onclick="toggleModelSelection()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>    
    <div id="modelSelectionArea" class="model-selection">
      <label for="selectOpenAI">
        <input type="checkbox" id="selectOpenAI" checked> OpenAI
      </label>
      <label for="selectMistral">
        <input type="checkbox" id="selectMistral" checked> Mistral
      </label>
      <label for="selectClaude">
        <input type="checkbox" id="selectClaude" checked> Anthropic Claude
      </label>
      <label for="selectGemini">
        <input type="checkbox" id="selectGemini" checked> Gemini
      </label>
      <label for="selectDeepSeek">
        <input type="checkbox" id="selectDeepSeek" checked> DeepSeek
      </label>
      <label for="selectGrok">
        <input type="checkbox" id="selectGrok" checked> Grok
      </label>         
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <!-- Leaderboard -->
    <div class="sidebar-header">
      <h2>
        Leaderboard 
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">Displays the user leaderboard based on their results.</span>
        </span>
      </h2>
      <button id="toggleLeaderboard" onclick="toggleLeaderboard()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="leaderboardContentContainer" class="hidden">
      <div id="leaderboardContent"></div>
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <div class="sidebar-section">
      <h2>Bookmarks
        <span class="sidebar-tooltip">
          <span class="info-icon">?</span>
          <span class="sidebar-tooltiptext">All your chats if you are logged in.</span>
        </span>
      </h2>
      <div id="bookmarksContainer"></div>
    </div>
  </div>
  <!-- Neuer Abschnitt in der Sidebar für Einstellungen -->
  <div class="sidebar-settings">
    <button id="editSystemPromptBtn" title="Settings">
      <span class="settings-icon">⚙️</span>
      <span class="settings-label">Settings</span>
    </button>
    <span id="version-number">v1.7.4</span>
  </div>
  
</div>
  <div class="container">
    <div class="input-section">
      <div class="chat-input-container" style="position: relative;">
        <textarea class="input-field" id="questionInput" placeholder="Enter your question"></textarea>
        <button id="toggleAllButton" onclick="toggleAllResponses()" title="Collapse or expand all answers">
          <span class="toggle-visual"></span>
        </button>
        <!-- Container für beide Schalter -->
        <div class="consensus-switch-container" style="position: absolute; bottom: 10px; left: 10px; display: flex; align-items: center; gap: 20px;">
          <!-- Auto-Konsens-Switch -->
          <div class="auto-consensus">
            <label class="switch">
              <input type="checkbox" id="autoConsensusToggle">
              <span class="slider"></span>
            </label>
            <span class="auto-consensus-label">Auto Consensus</span>
          </div>
          <!-- Search Mode Switch, standardmäßig leicht ausgegraut -->
          <div class="search-mode">
            <label class="switch">
              <input type="checkbox" id="searchModeToggle">
              <span class="slider"></span>
            </label>
            <span class="search-mode-label">Web Search</span>
            <!-- Disclaimer, der nur beim Aktivieren angezeigt wird -->
            <span id="searchDisclaimer" class="search-disclaimer" style="display: none; font-size: 0.8em; margin-left: 5px;">
              Models have access to the Internet.
            </span>
          </div>
          <div class="search-mode deep-search-mode">
            <label class="switch deep-switch">
              <input type="checkbox" id="deepSearchToggle">
              <span class="slider"></span>
            </label>
            <span class="search-mode-label deep-switch-label">Deep Think</span>
            <span id="deepthinkDisclaimer" class="deepthink-disclaimer" style="display: none; font-size: 0.8em; margin-left: 5px;">
              Reasoning models. More thoughtful responses.
            </span>
          </div>
        </div>
        <!-- Clear-Button nur mit Icon -->
        <button id="clearButton" onclick="clearResponseBoxes()" title="Clear all responses" aria-label="Clear all responses">Clear All</button>      
        <button class="button" id="sendButton" onclick="sendQuestion()">
          <!-- SVG-Icon für einen Pfeil, der nach unten zeigt -->
          <svg class="input-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="response-section" style="position: relative;">
      <!-- Antwort OpenAI -->
      <div class="response-box" id="openaiResponse" data-model="OpenAI">
        <h2>
          <span class="title">Response from ChatGPT <small>(<span id="openaiModelText">GPT-5-mini</span>)</small>
            <span class="model-picker-wrapper"><select id="openaiModelSelect" class="model-picker">
              <option value="gpt-5-mini">GPT-5-mini</option>
              <option value="gpt-5-nano">GPT-5-nano</option>
              <option value="gpt-4.1">GPT-4.1</option>
              <option value="gpt-4o">GPT-4o</option>
              <option value="gpt-3.5-turbo">GPT-3.5-turbo</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('openaiResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('openaiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('openaiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Mistral -->
      <div class="response-box" id="mistralResponse" data-model="Mistral">
        <h2>
          <span class="title">Response from Mistral <small>(<span id="mistralModelText">mistral-large-latest</span>)</small>
            <span class="model-picker-wrapper"><select id="mistralModelSelect" class="model-picker">
              <option value="mistral-large-latest">mistral-large-latest</option>
              <option value="mistral-medium-latest">mistral-medium-latest</option>
              <option value="mistral-small-latest">mistral-small-latest</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('mistralResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('mistralResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('mistralResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Anthropic Claude -->
      <div class="response-box" id="claudeResponse" data-model="Anthropic">
        <h2>
          <span class="title">Response from Claude <small>(<span id="claudeModelText">claude-haiku-4-5</span>)</small>
            <span class="model-picker-wrapper"><select id="claudeModelSelect" class="model-picker">
              <option value="claude-haiku-4-5">claude-haiku-4-5</option>
              <option value="claude-sonnet-4-20250514">claude-4-sonnet</option>
              <option value="claude-3-7-sonnet-20250219">claude-3-7-sonnet</option>
              <option value="claude-3-5-haiku-20241022">claude-3-5-haiku</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('claudeResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('claudeResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('claudeResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Gemini -->
      <div class="response-box" id="geminiResponse" data-model="Gemini">
        <h2>
          <span class="title">Response from Gemini <small>(<span id="geminiModelText">gemini-2.5-flash</span>)</small>
            <span class="model-picker-wrapper"><select id="geminiModelSelect" class="model-picker">
              <option value="gemini-2.5-flash">gemini-2.5-flash</option>
              <option value="gemini-2.0-flash">gemini-2.0-flash</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('geminiResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('geminiResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('geminiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort DeepSeek -->
      <div class="response-box" id="deepseekResponse" data-model="DeepSeek">
        <h2>
          <span class="title">Response from DeepSeek <small>(<span id="deepseekModelText">DeepSeek-V3</span>)</small>
            <span class="model-picker-wrapper"><select id="deepseekModelSelect" class="model-picker">
              <option value="deepseek-chat">DeepSeek-V3</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('deepseekResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('deepseekResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('deepseekResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Grok -->
      <div class="response-box" id="grokResponse" data-model="Grok">
        <h2>
          <span class="title">Response from Grok <small>(<span id="grokModelText">grok-4-fast</span>)</small>
            <span class="model-picker-wrapper"><select id="grokModelSelect" class="model-picker">
              <option value="grok-4-fast-non-reasoning-latest">grok-4-fast-non-reasoning-latest</option>
              <option value="grok-3-latest">grok-3</option>
            </select></span>
          </span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('grokResponse')" title="Mark as best answer">&#9733;</span>
            <span class="exclude-btn" onclick="toggleExclude('grokResponse')" title="Exclude answer">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('grokResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div> 
    </div>
    
    <!-- Konsens-Section -->
    <div class="consensus-section">
      <div class="consensus-wrapper">
        <!-- Konsens-Kontrolle: Schalter, Button und Dropdown wie gehabt -->
        <div class="consensus-controls">
          <!-- Tooltip-Wrapper um den Button -->
          <div class="tooltip">
            <button id="consensusButton" onclick="getConsensus()">Generate Consensus</button>
            <!-- Das Hover-Feld mit weiteren Infos -->
            <div class="tooltiptext">
              Combine four responses into a final, consistent consensus by reconciling contradictions and errors.
            </div>
          </div>
          <div class="consensus-model">
            <label for="consensusModelDropdown" class="consensus-label">Consensus Model:</label>
            <div class="select-wrapper">
              <select id="consensusModelDropdown">
                <option value="Grok">Grok-4-fast</option>
                <option value="OpenAI">GPT-5-mini</option>
                <option value="Anthropic">claude-haiku-4-5</option>
                <option value="Mistral">mistral-large-latest</option>
                <option value="Gemini">gemini-2.5-flash</option>
                <option value="DeepSeek">DeepSeek-V3</option>
              </select>
            </div>
          </div>
        </div>
        <!-- Konsens-Box mit zwei nebeneinanderliegenden Bereichen -->
        <div class="consensus-box" id="consensusResponse">
          <!-- Linker Bereich: Konsens-Antwort (80%) -->
          <div class="consensus-main">
            <h2>Consensus Answer</h2>
            <p></p>
          </div>
          <!-- Rechter Bereich: Unterschiede (20%) -->
          <div class="consensus-differences">
            <h2>Differences</h2>
            <p></p>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function() {
        // --------------------------
        // Dark/Light Mode Initialisierung
        // --------------------------
        // Zugriff auf die Checkboxen:

        // Global verfügbar für alle Funktionen
        window.spinnerHTML = `
          <span class="thinking-wrap" role="status" aria-live="polite" aria-busy="true">
            <span class="spinner" aria-hidden="true"></span>
            <span class="thinking" data-text="Thinking …">Thinking&nbsp;…</span>
          </span>
        `;

        window.currentEvidenceSources = [];

      /* === DEMO: Data & Utilities ======================================= */
      const DEMO_SCENARIO_PROMPT =
        "Should vegetarians take supplements? If yes, which ones?";

      const DEMO_DATA = {
        // realistic, staggered loading
        delays: { OpenAI: 1400, Mistral: 2500, Anthropic: 2900, Gemini: 3600, DeepSeek: 4300, Grok: 5000 },

        // short but differentiated answers to create real signal for Consensus & Differences
        // short but differentiated answers to create real signal for Consensus & Differences
        responses: {
          OpenAI:
        `<div class="ai-block">
          <p><u>Vegetarian supplementation (evidence-tiered)</u></p>
          <ul>
            <li><em>Core gap (near-universal):</em> Vitamin B12 → 50–100 µg/day or 1,000 µg once weekly (prefer cyanocobalamin for stability). Re-check B12 or MMA in 8–12 weeks.</li>
            <li><em>Likely gaps (context):</em> Vitamin D3 1,000–2,000 IU/day if little sun; monitor 25-OH D. Iodine 150 µg/day if no iodized salt/seaweed. Omega-3 (algae EPA+DHA) 250–500 mg/day; up to 1 g/day if triglycerides high.</li>
            <li><em>Possible gaps (diet pattern):</em> Iron only if labs show deficiency (check ferritin). Calcium to ~1,000 mg/day total; add 300–500 mg if short. Zinc 5–10 mg/day in phytate-heavy diets; ensure dietary copper ~1–2 mg/day long-term. Selenium 50–100 µg/day if uncertain; avoid &gt;200 µg long-term.</li>
            <li><em>Performance add-on:</em> Creatine monohydrate 3–5 g/day; vegetarians often respond strongly.</li>
          </ul>
          <p><small>Safety: third-party tested brands; watch interactions (e.g., levothyroxine ↔ iron/calcium; separate ≥4 h). General info, not medical advice.</small></p>
        </div>`,

          Mistral:
        `<div class="ai-block">
          <p><u>Vegetarian decision tree (if-this-then-that)</u></p>
          <ol>
            <li>Vegan or mostly plant-only days? → B12 50–100 µg/day (or 1,000 µg/week) = yes.</li>
            <li>Low sun / winter / indoor? → D3 1,000–2,000 IU/day → re-test in 8–12 weeks.</li>
            <li>No iodized salt / seaweed &lt;1–2×/week? → Iodine 150 µg/day (caution with thyroid disease).</li>
            <li>No fish + low ALA (flax/chia/walnuts)? → Algae EPA+DHA 250–500 mg/day.</li>
            <li>Heavy training or sprint/strength goals? → Creatine 3 g/day (monohydrate).</li>
            <li>Heavy periods/fatigue? → Labs first; iron only if ferritin low.</li>
            <li>Low dairy/fortified milk? → Add Calcium 300–500 mg to hit ~1,000 mg/day.</li>
          </ol>
          <p><small>Rules: keep stack small, test → trial → re-test; swap forms for tolerance (e.g., magnesium glycinate/citrate).</small></p>
        </div>`,

          Anthropic:
        `<div class="ai-block">
          <p><u>Clinical workflow (vegetarian)</u></p>
          <ul>
            <li><em>Default:</em> B12 (50–100 µg/day or 1,000 µg weekly). Confirm correction with B12/MMA after 8–12 weeks.</li>
            <li><em>Common additions (risk-based):</em> D3 1,000–2,000 IU/day with 25-OH D monitoring; Iodine 150 µg/day if not using iodized salt/seaweed (seek clinician input if thyroid disease); Algae EPA+DHA 250–500 mg/day if fish-free.</li>
            <li><em>Conditional:</em> Iron only when deficient (dose/duration per labs). Calcium to ~1,000 mg/day total; small supplement if shortfall. Zinc 5–10 mg/day with phytate-heavy intake; consider dietary copper balance. Creatine 3–5 g/day for performance/cognition potential.</li>
          </ul>
          <p><small>Process: baseline labs → targeted 8–12 week trial → follow-up labs; document symptoms, side effects, and drug–nutrient interactions (e.g., levothyroxine spacing).</small></p>
        </div>`,

          Gemini:
        `<div class="ai-block">
          <p><u>Persona matrix (vegetarian)</u></p>
          <ul>
            <li><em>Lacto-ovo office worker:</em> B12 50–100 µg/day; D3 in winter; Algae EPA+DHA 250–500 mg/day if omega-3 intake low.</li>
            <li><em>Endurance/strength athlete:</em> B12; Creatine 3–5 g/day; D3 if low; consider magnesium 200–400 mg at night (glycinate/citrate).</li>
            <li><em>Trying/pregnant:</em> Folate 400 µg/day, B12, ensure iodine 150 µg/day; iron per labs; choose a moderate-dose prenatal.</li>
            <li><em>South/SE-Asian vegetarian pattern:</em> prioritize iodine 150 µg/day, B12, D3.</li>
            <li><em>Low-dairy:</em> reach ~1,000 mg/day calcium via foods/fortified milks; add 300–500 mg if needed.</li>
          </ul>
          <p><small>Notes: Algae EPA+DHA = vegetarian; lanolin-derived D3 is vegetarian (lichen-D3 if vegan). Reassess quarterly.</small></p>
        </div>`,

          DeepSeek:
        `<div class="ai-block">
          <p><u>Ops &amp; safety checklist</u></p>
          <ul>
            <li><em>Do:</em> use USP/NSF/IFOS-certified brands; keep a start-date/dose log; set a 12-week review.</li>
            <li><em>Separate:</em> iron/calcium from levothyroxine by ≥4 h; calcium can blunt iron absorption — don’t take together.</li>
            <li><em>Avoid:</em> megadoses of A/D/E/K; assuming “sea salt” is iodized (often not).</li>
          </ul>
          <p><em>Minimal viable vegetarian stack (by scenario)</em></p>
          <ul>
            <li>Default: B12; D3 if low sun.</li>
            <li>No iodized salt/seaweed: Iodine 150 µg/day.</li>
            <li>No fish &amp; low ALA: Algae EPA+DHA 250–500 mg/day.</li>
            <li>Performance: Creatine 3 g/day.</li>
            <li>Low dairy: Calcium 300–500 mg to reach ~1,000 mg/day.</li>
          </ul>
        </div>`,

          Grok:
        `<div class="ai-block">
          <p><u>Straight-talk (vegetarian)</u></p>
          <ul>
            <li>If you eat well and see the sun, your baseline is B12; most else is “it depends”.</li>
            <li>Add D3 when winter hits, algae EPA+DHA if fish = zero, iodine if your salt isn’t iodized.</li>
            <li>Iron only with labs. Creatine if you actually train.</li>
            <li>Keep doses sane; skip influencer mega-stacks. Your body isn’t a supplement shelf.</li>
          </ul>
        </div>`
        },

        consensus:
        `<div class="ai-consensus">
          <p><u>Consensus (Demo — vegetarian focus)</u></p>
          <p>Vegetarians benefit from a <em>targeted</em> supplement approach rather than large stacks. The near-universal baseline is <span>B12 50–100 µg/day</span> or <span>1,000 µg weekly</span>. Add context-dependent items:</p>
          <ul>
            <li>D3 1,000–2,000 IU/day if sun exposure or blood levels are low.</li>
            <li>Iodine 150 µg/day if you don’t use iodized salt/seaweed (seek clinical guidance with thyroid disease).</li>
            <li>Algae EPA+DHA 250–500 mg/day if fish-free.</li>
            <li>Iron only with confirmed deficiency (use labs; check ferritin).</li>
            <li>Calcium to reach ~1,000 mg/day total; consider a small supplement if dietary intake is short.</li>
            <li>Zinc 5–10 mg/day for phytate-heavy patterns; mind copper intake over the long term.</li>
            <li>Creatine 3–5 g/day for athletic/performance goals.</li>
          </ul>
          <p><small>Choose third-party tested products, check interactions (e.g., spacing levothyroxine from iron/calcium), and re-test labs after an 8–12 week trial. General info, not medical advice.</small></p>
        </div>`,

      differences:
      `<div class="ai-differences">
        <p><span class="cred-badge cred-largely">The consensus answer is largely credible.</span></p>
        <hr>
        <p>Most models agree on the core stack (B12 baseline; D3, iodine, algae EPA+DHA as context; iron only with labs; calcium to ~1,000 mg; creatine for athletes). Minor content nuances appear (e.g., zinc/copper balance, magnesium for sleep/performance, process/QA details) without contradictions.</p>
        <p><br>BestModel: Anthropic</p>
      </div>`
      };

      /* === DEMO: Timing & Typing Configuration =============================== */
      const DEMO_PHASES = {
        preType: true,
        order: ["OpenAI","Anthropic","Gemini","Mistral","DeepSeek","Grok"],
        typeChars: 90,         // how many prompt characters to "type"
        typeSpeed: 40,         // ms per character
        gapBetweenModels: 540, // pause between models
        pauseAfterTypingAll: 650
      };

      const DEMO_CONSENSUS_DELAY_MS = 4200;
      const DEMO_CONSENSUS_JITTER_MS = 600;

      // Ladezeiten etwas länger machen (ohne alles neu zu tippen)
      const DEMO_DELAY_BOOST_MS = 1800;
      Object.keys(DEMO_DATA.delays).forEach(k => {
        DEMO_DATA.delays[k] = (DEMO_DATA.delays[k] || 1500) + DEMO_DELAY_BOOST_MS;
      });

      const MODEL_TO_BOX = {
        OpenAI: "openaiResponse",
        Mistral: "mistralResponse",
        Anthropic: "claudeResponse",
        Gemini: "geminiResponse",
        DeepSeek: "deepseekResponse",
        Grok: "grokResponse"
      };

      const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

      // Tippt Text in das Input/Textarea-Feld
      async function typeIntoInput(inputEl, text, speed = 14) {
        if (!inputEl) return;
        inputEl.focus();
        inputEl.value = "";
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        for (let i = 0; i < text.length; i++) {
          inputEl.value += text[i];
          inputEl.dispatchEvent(new Event("input", { bubbles: true }));
          const jitter = Math.random() * 6 - 3; // -3..+3ms
          await sleep(Math.max(4, speed + jitter));
          if (typeof inputEl.scrollTop === "number") inputEl.scrollTop = inputEl.scrollHeight;
        }
      }

      function getBox(model){
        const id = MODEL_TO_BOX[model];
        const box = document.getElementById(id);
        if (!box || box.classList.contains("excluded") || box.style.display === "none") return null;
        return box;
      }

      async function typeInto(el, text, speed){
        el.textContent = "";
        for (let i=0;i<text.length;i++){
          el.textContent += text[i];
          // kleine Randomisierung wirkt natürlicher
          const jitter = Math.random()*6 - 3; // -3..+3
          await sleep(Math.max(4, speed + jitter));
        }
      }

        function setSpinnerEl(box){
          const p = box.querySelector(".collapsible-content");
          if (p) p.innerHTML = window.spinnerHTML;
        }

        // Utils: Markdown → HTML (sanitised) + deine Addons
        function injectMarkdown(el, md) {
          el.innerHTML = DOMPurify.sanitize(marked.parse(md || ""));

          if (window.addCopyButtons) window.addCopyButtons(el);
          if (window.addNewTabToLinks) window.addNewTabToLinks(el);

          if (window.currentEvidenceSources && window.currentEvidenceSources.length && window.linkifySourceTags) {
            window.linkifySourceTags(el, window.currentEvidenceSources);
          }
        }

        function linkifySourceTags(containerEl, sources) {
          if (!sources || !sources.length) return;

          let html = containerEl.innerHTML;

          html = html.replace(/\[(S[1-9]\d*)\]/g, (match, id) => {
            const index = parseInt(id.slice(1), 10) - 1; // S1 -> 0
            const src = sources[index];
            if (!src || !src.url) return match;

            const url = src.url;
            const safeId = id; // "S1"
            return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="source-link">[${safeId}]</a>`;
          });

          containerEl.innerHTML = html;
        }

        window.linkifySourceTags = linkifySourceTags;


        function setSpinner(boxId) {
          const box = document.getElementById(boxId);
          if (!box || box.classList.contains("excluded") || box.style.display === "none") return;
          const p = box.querySelector(".collapsible-content");
          if (p) p.innerHTML = window.spinnerHTML;
        }

        function setSpinnersForActive() {
          ["openaiResponse","mistralResponse","claudeResponse","geminiResponse","deepseekResponse","grokResponse"]
            .forEach(setSpinner);
        }

      // Der eigentliche Demo-Lauf
      async function runDemoFlow() {
        // Buttons blocken
        const sendBtn = document.getElementById("sendButton");
        const consensusBtn = document.getElementById("consensusButton");
        if (sendBtn) sendBtn.disabled = true;
        if (consensusBtn) consensusBtn.disabled = true;

        // Prompt in das Eingabefeld setzen
        const qi = document.getElementById("questionInput");
        if (qi && !qi.value.trim()) qi.value = DEMO_SCENARIO_PROMPT;

        // === 1) Vorphase: so tun, als würden wir an Modelle „eingeben“ ==========
        // === 1) Vorphase: Prompt in das Input-Feld „tippen“ ======================
        if (DEMO_PHASES.preType) {
          const qiEl = document.getElementById("questionInput");
          const snippet =
            DEMO_SCENARIO_PROMPT.slice(0, DEMO_PHASES.typeChars) +
            (DEMO_SCENARIO_PROMPT.length > DEMO_PHASES.typeChars ? "…" : "");
          await typeIntoInput(qiEl, snippet, DEMO_PHASES.typeSpeed);
          await sleep(DEMO_PHASES.pauseAfterTypingAll);
        }

        // === 2) Jetzt erst Spinners in alle aktiven Boxen =======================
        Object.keys(MODEL_TO_BOX).forEach(key => {
          const box = getBox(key);
          if (box) setSpinnerEl(box);
        });

        // === 3) Gestaffelte Antworten „einlaufen“ lassen ========================
        await Promise.all(Object.keys(MODEL_TO_BOX).map(model =>
          new Promise(resolve => {
            setTimeout(() => {
              const box = getBox(model);
              if (box){
                const p = box.querySelector(".collapsible-content");
                if (p) injectMarkdown(p, DEMO_DATA.responses[model]);
              }
              resolve();
            }, DEMO_DATA.delays[model] || 1800);
          })
        ));

        // === 4) Consensus/Differences – wie gehabt ==============================
        const consensusDiv = document.getElementById("consensusResponse");
        const mainP = consensusDiv?.querySelector(".consensus-main p");
        const diffP = consensusDiv?.querySelector(".consensus-differences p");
        const auto = document.getElementById("autoConsensusToggle")?.checked;

        const renderConsensus = () => {
          if (mainP) injectMarkdown(mainP, DEMO_DATA.consensus);
          if (diffP) {
            const html = marked.parse((window.colorizeCredibility?.(DEMO_DATA.differences) ?? DEMO_DATA.differences));
            diffP.innerHTML = DOMPurify.sanitize(html);
          }
          const best = (DEMO_DATA.differences.match(/BestModel:\s*(.*)/i)?.[1] || "").trim();
          if (best) window.recordModelVote?.(best, "BestModel");
        };

        if (auto){
          if (mainP) mainP.innerHTML = window.spinnerHTML;
          if (diffP) diffP.innerHTML = window.spinnerHTML;
          setTimeout(
            renderConsensus,
            DEMO_CONSENSUS_DELAY_MS + Math.floor(Math.random() * DEMO_CONSENSUS_JITTER_MS)
          );

        } else if (consensusBtn){
          const originalOnclick = consensusBtn.onclick;
          consensusBtn.onclick = () => {
            if (mainP) mainP.innerHTML = window.spinnerHTML;
            if (diffP) diffP.innerHTML = window.spinnerHTML;
            setTimeout(
              renderConsensus,
              DEMO_CONSENSUS_DELAY_MS + Math.floor(Math.random() * DEMO_CONSENSUS_JITTER_MS)
            );
            consensusBtn.onclick = originalOnclick;
          };
        }

        // Buttons wieder freigeben
        if (sendBtn) sendBtn.disabled = false;
        if (consensusBtn) consensusBtn.disabled = false;
      }

        // “Start Demo”-Chip erzeugen (einmalig pro Gerät)
        function createStartDemoChip() {
          if (localStorage.getItem("demoChipDismissed")) return;
          const container = document.querySelector(".chat-input-container");
          if (!container || container.querySelector(".demo-chip")) return;

          const btn = document.createElement("button");
          btn.className = "demo-chip";
          btn.type = "button";
          btn.setAttribute("aria-label","Start interactive demo");
          btn.textContent = "Start Demo";

          btn.addEventListener("click", async () => {
            localStorage.setItem("demoChipDismissed","1");
            btn.remove();
            await runDemoFlow();
          });

          container.appendChild(btn);
        }
        /* === DEMO Ende ====================================================== */

        const deepSearchToggle = document.getElementById("deepSearchToggle");
        const searchModeToggle = document.getElementById("searchModeToggle");

        // Auslesen des aktuellen Zustands (true, wenn aktiviert, sonst false):
        const deepSearchActive = deepSearchToggle.checked;
        const searchModeActive = searchModeToggle.checked;
  
        function applyTheme(theme) {
          if (theme === "dark") {
            document.body.classList.add("dark-mode");
            modeToggle.checked = true;
          } else {
            document.body.classList.remove("dark-mode");
            modeToggle.checked = false;
          }
        }
  
        // Lese gespeicherten Wert aus; wenn keiner vorhanden, verwende die Systempräferenz:
        let storedTheme = localStorage.getItem("theme");
        if (!storedTheme) {
          storedTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
          localStorage.setItem("theme", storedTheme);
        }
        applyTheme(storedTheme);
  
        // Schalte den Dark Mode um und speichere die Auswahl:
        modeToggle.addEventListener("change", function() {
          const newTheme = this.checked ? "dark" : "light";
          localStorage.setItem("theme", newTheme);
          applyTheme(newTheme);
        });
  
        // --- Speichern des Auto Consensus Zustands ---
        const autoConsensusToggle = document.getElementById("autoConsensusToggle");
        // Beim Laden den gespeicherten Zustand auslesen
        let storedAutoConsensus = localStorage.getItem("autoConsensus");
        if (storedAutoConsensus === null) {
          // Falls noch kein Wert gespeichert wurde, Standard: true (an)
          autoConsensusToggle.checked = true;
          localStorage.setItem("autoConsensus", "true");
        } else {
          autoConsensusToggle.checked = storedAutoConsensus === "true";
        }
        // Bei Änderung den neuen Zustand speichern
        autoConsensusToggle.addEventListener("change", function() {
          localStorage.setItem("autoConsensus", this.checked);
        });
  
        const questionInput = document.getElementById("questionInput");
        // Prüfe, ob der Nutzer eingeloggt ist (z.B. über ein gespeichertes Token)
        const isLoggedIn = !!localStorage.getItem("id_token");
        // Prüfe, ob mindestens ein API Key vorhanden ist
        const hasApiKeys = localStorage.getItem("openaiKey") ||
                          localStorage.getItem("mistralKey") ||
                          localStorage.getItem("anthropicKey") ||
                          localStorage.getItem("geminiKey") ||
                          localStorage.getItem("deepseekKey") ||
                          localStorage.getItem("grokKey");
        
        if (isLoggedIn || hasApiKeys) {
          questionInput.placeholder = "Enter your question";
        } else {
          questionInput.placeholder = "Please log in or store your own API keys.";
        }

      function updateDeepThinkText() {
        const deepSearchToggle = document.getElementById("deepSearchToggle");
        const searchToggle     = document.getElementById("searchModeToggle");

        const deepSearchActive = !!deepSearchToggle && deepSearchToggle.checked;
        const searchModeActive = !!searchToggle && searchToggle.checked;

        const deepthinkDisclaimer = document.getElementById("deepthinkDisclaimer");
        const searchDisclaimer    = document.getElementById("searchDisclaimer"); // wird nur versteckt

        // -------------------------
        // Texte vorbereiten
        // -------------------------
        const deepText = searchModeActive
          ? "DeepSearch models. Thoughtful plus internet."
          : "Reasoning models. More thoughtful responses.";

        const searchText = "Models have access to the Internet.";

        // -------------------------
        // Mobile / kleine Screens: Popup
        // -------------------------
        if (window.innerWidth < 1400) {
          // Priorität Deep Think: wenn beides an ist, nur Deep Think Text zeigen
          if (deepSearchActive) {
            showPopup(deepText);
          } else if (searchModeActive) {
            showPopup(searchText);
          }

          if (deepthinkDisclaimer) deepthinkDisclaimer.style.display = "none";
          if (searchDisclaimer)    searchDisclaimer.style.display    = "none";
        } else {
          // -------------------------
          // Desktop: Text RECHTS vom Deep-Think-Toggle
          // -------------------------
          if (deepthinkDisclaimer) {
            if (deepSearchActive || searchModeActive) {
              // Priorität:
              // 1) Deep Think aktiv -> Deep Text
              // 2) Nur Web Search aktiv -> Web-Search-Text
              if (deepSearchActive) {
                deepthinkDisclaimer.textContent = deepText;
              } else {
                deepthinkDisclaimer.textContent = searchText;
              }
              deepthinkDisclaimer.style.display = "inline-block";
            } else {
              deepthinkDisclaimer.style.display = "none";
            }
          }

          // Den ursprünglichen Web-Search-Disclaimer-Span ausblenden
          if (searchDisclaimer) {
            searchDisclaimer.style.display = "none";
          }
        }

        // -------------------------
        // Model-Picker zeigen/verstecken
        // -------------------------
        const showPickers = !deepSearchActive;
        document.querySelectorAll(".model-picker-wrapper").forEach(el => {
          el.style.display = showPickers ? "inline-flex" : "none";
        });

        const openaiModelText   = deepSearchActive ? "GPT-5" : "GPT-5-mini";
        const geminiModelText   = deepSearchActive ? "gemini-2.5-pro" : "gemini-2.5-flash";
        const claudeModelText   = deepSearchActive ? "claude-sonnet-4-5-20250929" : "claude-haiku-4-5";
        const deepseekModelText = deepSearchActive ? "DeepSeek-R1" : "DeepSeek-V3";
        const grokModelText     = deepSearchActive ? "grok-4-latest" : "grok-4-fast-non-reasoning";

        const setModelText = (id, txt) => {
          const el = document.getElementById(id);
          if (el) el.textContent = txt;
        };
        setModelText("openaiModelText",   openaiModelText);
        setModelText("geminiModelText",   geminiModelText);
        setModelText("claudeModelText",   claudeModelText);
        setModelText("deepseekModelText", deepseekModelText);
        setModelText("grokModelText",     grokModelText);
      }

        // Event-Listener registrieren:
        document.getElementById("deepSearchToggle").addEventListener("change", updateDeepThinkText);
        document.getElementById("searchModeToggle").addEventListener("change", updateDeepThinkText);
        updateDeepThinkText();

        // --------------------------
        // Marketing Popup Initialisierung
        // --------------------------
        // Überprüfen, ob das Popup schon angezeigt wurde
  
        const FREE_USAGE_LIMIT = 25;
  
        if (!localStorage.getItem("marketingPopupShown")) {
          document.getElementById("marketingPopup").style.display = "block";
          document.body.classList.add("modal-open");
        }
  
        // Popup schließen, wenn auf das "x" geklickt wird
        document.querySelector("#marketingPopup .close").addEventListener("click", function() {
          document.getElementById("marketingPopup").style.display = "none";
          document.body.classList.remove("modal-open");
          localStorage.setItem("marketingPopupShown", "true");
        });
  
        // Popup schließen, wenn der "Jetzt starten"-Button geklickt wird
        document.getElementById("startNowButton").addEventListener("click", function() {
          document.getElementById("marketingPopup").style.display = "none";
          document.body.classList.remove("modal-open");
          localStorage.setItem("marketingPopupShown", "true");
          // >>> Nur Chip einblenden, kein Auto-Start
          createStartDemoChip();
        });
  
        document.addEventListener("click", function(event) {
          const sidebar = document.querySelector('.sidebar');
          const burgerButton = document.querySelector('.sidebar-toggle');
          
          // Nur auf kleinen Displays
          if (window.innerWidth <= 1465 && sidebar.classList.contains("active")) {
            // Wenn der Klick weder innerhalb der Sidebar noch auf dem Burger-Button erfolgt
            if (!sidebar.contains(event.target) && !event.target.closest('.sidebar-toggle')) {
              sidebar.classList.remove("active");
              
            }
          }
        });
  
        // Elemente für den Search Mode:
        //const deepSearchToggle = document.getElementById("deepSearchToggle");
        const deepthinkDisclaimer = document.getElementById("deepthinkDisclaimer");
        const consensusDropdown = document.getElementById("consensusModelDropdown");
        
        // Checkboxen für die Modelle:
        const openaiCheckbox = document.getElementById("selectOpenAI");
        const mistralCheckbox = document.getElementById("selectMistral");
        const claudeCheckbox = document.getElementById("selectClaude");
        const geminiCheckbox = document.getElementById("selectGemini");
        const deepseekCheckbox = document.getElementById("selectDeepSeek");
        const grokCheckbox = document.getElementById("selectGrok");

        // Mapping: Response-Box → zugehörige Sidebar-Checkbox
        function getCheckboxForResponse(responseId) {
          switch (responseId) {
            case "openaiResponse":   return openaiCheckbox;
            case "mistralResponse":  return mistralCheckbox;
            case "claudeResponse":   return claudeCheckbox;
            case "geminiResponse":   return geminiCheckbox;
            case "deepseekResponse": return deepseekCheckbox;
            case "grokResponse":     return grokCheckbox;
            default: return null;
          }
        }
  
        // Label-Container der Checkboxen:
        const openaiLabel = document.querySelector("label[for='selectOpenAI']");
        const mistralLabel = document.querySelector("label[for='selectMistral']");
        const claudeLabel = document.querySelector("label[for='selectClaude']");
        const deepseekLabel = document.querySelector("label[for='selectDeepSeek']");
        const grokLabel = document.querySelector("label[for='selectGrok']");
        const geminiLabel = document.querySelector("label[for='selectGemini']");
  
        // Funktion, um Response-Boxen komplett auszublenden oder einzublenden:
        function setResponseBoxDisplay(id, displayValue) {
          const el = document.getElementById(id);
          if (el) {
            el.style.display = displayValue;
          }
        }
  
        // Funktion, um Buttons in den Response-Boxen zu deaktivieren/aktivieren:
        function updateButtons(selector, disable) {
          const btns = document.querySelectorAll(selector);
          btns.forEach(btn => {
            if (disable) {
              btn.style.pointerEvents = "none";
              btn.style.opacity = "0.5";
            } else {
              btn.style.pointerEvents = "";
              btn.style.opacity = "";
            }
          });
        }
  
        // Beispiel für das Setzen des systemPrompt-Wertes, falls noch nicht gesetzt:
        const defaultPrompt = "Please respond briefly and precisely, focusing only on the essentials.";
        if (!localStorage.getItem("systemPrompt")) {
          localStorage.setItem("systemPrompt", defaultPrompt);
        }
  
        // Öffnen des Modals beim Klick auf das Zahnrad
        document.getElementById("editSystemPromptBtn").addEventListener("click", function() {
          const modal = document.getElementById("systemPromptModal");
          const textarea = document.getElementById("systemPromptInput");
          textarea.value = localStorage.getItem("systemPrompt");
          modal.style.display = "block";
        });
  
        // Schließen des Modals
        document.getElementById("closeSystemPromptModal").addEventListener("click", function() {
          document.getElementById("systemPromptModal").style.display = "none";
        });
  
        // Speichern des neuen Prompts
        document.getElementById("saveSystemPromptBtn").addEventListener("click", function() {
          const newPrompt = document.getElementById("systemPromptInput").value.trim();
          localStorage.setItem("systemPrompt", newPrompt); // Speichert auch leere Strings!
          document.getElementById("systemPromptModal").style.display = "none";
        });
  
        // Öffnen des Hilfemodals beim Klick auf den Hilfebutton
        document.getElementById("helpButton").addEventListener("click", function() {
          document.getElementById("helpModal").style.display = "block";
        });
  
        // Schließen des Modals beim Klick auf das Schließen-Symbol
        document.getElementById("closeHelpModal").addEventListener("click", function() {
          document.getElementById("helpModal").style.display = "none";
        });
  
        // Optional: Modal schließen, wenn außerhalb geklickt wird
        window.addEventListener("click", function(event) {
          if (event.target === document.getElementById("helpModal")) {
            document.getElementById("helpModal").style.display = "none";
          }
        });

        // Öffnen des Feedback-Modals beim Klick auf den Feedback-Button
        document.getElementById("feedbackButton").addEventListener("click", function() {
          document.getElementById("feedbackModal").style.display = "block";
        });

        // Schließen des Feedback-Modals beim Klick auf das Schließen-Symbol
        document.getElementById("closeFeedbackModal").addEventListener("click", function() {
          document.getElementById("feedbackModal").style.display = "none";
        });

        // Optional: Modal schließen, wenn außerhalb des Modal-Inhalts geklickt wird
        window.addEventListener("click", function(event) {
          if (event.target === document.getElementById("feedbackModal")) {
            document.getElementById("feedbackModal").style.display = "none";
          }
        });
  
        // Toggle FAQ items with icons
        document.querySelectorAll('.faq-item h3').forEach((question) => {
          question.addEventListener('click', () => {
            const answer = question.nextElementSibling;
            const icon = question.querySelector('.faq-toggle-icon');
            if (!answer.style.display || answer.style.display === 'none') {
              answer.style.display = 'block';
              icon.textContent = '－';
            } else {
              answer.style.display = 'none';
              icon.textContent = '＋';
            }
          });
        });
  
        // Standardmäßig Antworten ausgeblendet (optional)
        document.querySelectorAll('.faq-item p').forEach((answer) => {
          answer.style.display = 'none';
        });
  
        const DEFAULT_MAX_WORDS = 300;
        const DEEP_SEARCH_MAX_WORDS = 1000;

        function validateInputText() {
          const text = document.getElementById("questionInput").value.trim();
          const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
          // Prüfe, ob der Deep Think Toggle aktiv ist:
          const deepSearchActive = document.getElementById("deepSearchToggle").checked;
          // Setze das Wortlimit abhängig vom Deep Think Status
          const maxWords = deepSearchActive ? DEEP_SEARCH_MAX_WORDS : DEFAULT_MAX_WORDS;
          
          if (wordCount > maxWords) {
            alert(`Die Eingabe überschreitet das erlaubte Wortlimit von ${maxWords} Wörtern (aktuell ${wordCount}).`);
            return false;
          }
          return true;
        }
  
        document.getElementById("sendButton").addEventListener("click", function(e) {
          if (!validateInputText()) {
            e.preventDefault();
          }
        });
  
        // --------------------------
        // Event-Listener für Eingabefelder und Buttons
        // --------------------------
      
        // Frage per Enter (ohne Zeilenumbruch) absenden
        document.getElementById("questionInput").addEventListener("keydown", function(event) {
          if (event.key === "Enter" && !event.shiftKey) {
            // Wenn der Button deaktiviert ist, breche die Ausführung ab
            if (document.getElementById("sendButton").disabled) {
              event.preventDefault();
              return;
            }
            event.preventDefault();
            sendQuestion();
          }
        });
      
        document.getElementById("toggleSidebarButton").addEventListener("click", function() {
          const sidebar = document.querySelector(".sidebar");
          sidebar.classList.toggle("collapsed");
        });
  
        document.getElementById('toggleSidebarButton').addEventListener('click', function() {
          const sidebar = document.querySelector('.sidebar');
          sidebar.classList.toggle('active');
        });
      
        // Fenstergröße prüfen – wenn <1024px, Sidebar einklappen
        function checkWindowSize() {
          const sidebar = document.querySelector(".sidebar");
          if (window.innerWidth < 1024) {
            sidebar.classList.add("collapsed");
          } else {
            sidebar.classList.remove("collapsed");
          }
          updateToggleButton();
        }
        window.addEventListener("resize", checkWindowSize);
        checkWindowSize(); // Initial
      
        // Aktualisiert den Pfeil des Sidebar-Toggle-Buttons
        function updateToggleButton() {
          const sidebar = document.querySelector(".sidebar");
          const newText = sidebar.classList.contains("collapsed") ? "►" : "◄";
          const arrow = document.querySelector(".sidebar-toggle .arrow");
          if (arrow) {
            arrow.textContent = newText;
          }
        }
  
        // Extrahiert aus dem Differences-Text den BestModel-Wert
        function parseBestModel(differencesText) {
          const regex = /BestModel:\s*(.*)/i;
          const match = differencesText.match(regex);
          return match ? match[1].trim() : null;
        }
  
        // Funktion, um das Popup anzuzeigen
        function showPopup(message) {
          const popup = document.createElement('div');
          popup.className = 'explanation-popup';
          popup.innerText = message;
          document.body.appendChild(popup);
          
          setTimeout(() => {
            popup.style.opacity = '1';
          }, 100);
          
          setTimeout(() => {
            popup.style.opacity = '0';
            setTimeout(() => {
              popup.remove();
            }, 300);
          }, 3000);
        }

        function renderEvidenceSources(sources) {
          const container = document.getElementById("evidenceContainer");
          const listEl = document.getElementById("evidenceList");

          if (!container || !listEl) {
            // Wenn du das UI noch nicht eingebaut hast, einfach leise aussteigen
            return;
          }

          listEl.innerHTML = "";

          if (!sources || !sources.length) {
            container.style.display = "none";
            return;
          }

          sources.forEach((src, idx) => {
            const li = document.createElement("li");
            li.className = "evidence-item";

            const titleRow = document.createElement("div");
            titleRow.className = "evidence-title-row";

            const indexSpan = document.createElement("span");
            indexSpan.className = "evidence-index";
            indexSpan.textContent = (idx + 1) + ". ";

            const link = document.createElement("a");
            link.href = src.url || "#";
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = src.title || src.url || "Source " + (idx + 1);

            titleRow.appendChild(indexSpan);
            titleRow.appendChild(link);
            li.appendChild(titleRow);

            if (src.snippet || src.text) {
              const snippetDiv = document.createElement("div");
              snippetDiv.className = "evidence-snippet";
              snippetDiv.textContent = src.snippet || src.text;
              li.appendChild(snippetDiv);
            }

            listEl.appendChild(li);
          });

          container.style.display = "block";
        }

        // global machen, falls du es anderswo brauchst
        window.renderEvidenceSources = renderEvidenceSources;
      
        // --------------------------
        // Globale Funktionen (für Inline-Aufrufe)
        // --------------------------
  
        window.toggleBest = function(responseId) {
          const box = document.getElementById(responseId);
          if (box.classList.contains("excluded")) return;
          // Nur Popup anzeigen, wenn die Antwort nicht bereits als "best" markiert ist
          if (!box.classList.contains("best")) {
            showPopup("You mark this answer as the best answer. This way it will be highlighted and given special attention in the consensus.");
          }
          if (box.classList.contains("best")) {
            box.classList.remove("best");
          } else {
            document.querySelectorAll(".response-box").forEach(b => b.classList.remove("best"));
            box.classList.add("best");
            const model = box.getAttribute("data-model");
            // Direkter Aufruf zur Firebase-Funktion:
            recordModelVote(model, "best");
          }
        };
  
        // API Testbereich umschalten (für den Pfeil in der API Keys Section)
        window.toggleApiTest = function() {
          const area = document.getElementById("apiTestArea");
          const button = document.getElementById("toggleApiTest");
          const arrow = button.querySelector(".arrow");
          if (area.style.display === "none" || area.style.display === "") {
            area.style.display = "block";
            arrow.classList.add("rotated");
          } else {
            area.style.display = "none";
            arrow.classList.remove("rotated");
          }
        };
      
        // Modelle-Auswahl umschalten (für den Pfeil in der Modelle Section)
        window.toggleModelSelection = function() {
          const area = document.getElementById("modelSelectionArea");
          const button = document.getElementById("toggleModelSelection");
          const arrow = button.querySelector(".arrow");
          if (area.style.display === "none" || area.style.display === "") {
            area.style.display = "block";
            arrow.classList.add("rotated");
          } else {
            area.style.display = "none";
            arrow.classList.remove("rotated");
          }
        };
  
        window.toggleAllResponses = function() {
          const responses = document.querySelectorAll('.response-box');
          let shouldCollapse = false;
          responses.forEach(box => {
            const content = box.querySelector('.collapsible-content');
            if (content && !content.classList.contains('collapsed')) {
              shouldCollapse = true;
            }
          });
          
          responses.forEach(box => {
            const content = box.querySelector('.collapsible-content');
            const arrow = box.querySelector('.collapse-btn .arrow');
            if (shouldCollapse) {
              if (content && !content.classList.contains('collapsed')) {
                content.classList.add('collapsed');
              }
              if (arrow && !arrow.classList.contains('rotated')) {
                arrow.classList.add('rotated');
              }
            } else {
              if (content && content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
              }
              if (arrow && arrow.classList.contains('rotated')) {
                arrow.classList.remove('rotated');
              }
            }
          });
        };
      
        // Collapse/Expand einer Antwort-Box
        window.toggleCollapse = function(responseId) {
          const responseBox = document.getElementById(responseId);
          const content = responseBox.querySelector(".collapsible-content");
          const arrow = responseBox.querySelector(".collapse-btn .arrow");
          content.classList.toggle("collapsed");
          arrow.classList.toggle("rotated");
        };
      
        // Exclude/Include einer Antwort-Box (falls nicht als "best" markiert)
        // ➜ steuert jetzt auch die Sidebar-Checkboxen / modelSelectionArea mit
        window.toggleExclude = function(responseId) {
          const box = document.getElementById(responseId);
          if (!box) return;

          // "Best" bleibt unverändert
          if (box.classList.contains("best")) return;

          const checkbox = getCheckboxForResponse(responseId);

          // Fallback: falls aus irgendeinem Grund keine Checkbox gefunden wird,
          // verhalte dich wie früher (nur .excluded toggeln).
          if (!checkbox) {
            if (!box.classList.contains("excluded")) {
              showPopup("You have excluded this answer. It will be removed from the view and not included in the consensus.");
            }
            box.classList.toggle("excluded");
            return;
          }

          // Aktuellen Zustand der Sidebar-Checkbox auslesen
          const currentlyChecked = checkbox.checked;
          const willBeChecked    = !currentlyChecked;   // toggle

          // Nur beim Wechsel von "inkludiert" → "exkludiert" Popup zeigen
          if (currentlyChecked && !box.classList.contains("excluded")) {
            showPopup("You have excluded this answer. It will be removed from the view and not included in the consensus.");
          }

          // Sidebar-Checkbox umschalten
          checkbox.checked = willBeChecked;

          // Und **immer** über toggleModel gehen, damit .excluded in Sync bleibt
          window.toggleModel(responseId, willBeChecked);
        };
      
        let leaderboardInterval; // Variable zum Speichern des Interval-IDs
  
        window.toggleLeaderboard = function() {
          const container = document.getElementById("leaderboardContentContainer");
          const arrow = document.getElementById("toggleLeaderboard").querySelector(".arrow");
          container.classList.toggle("hidden");
          arrow.classList.toggle("rotated");
        };
  
        // Globale Variable
        let consensusGenerated = false;
        document.getElementById("consensusButton").disabled = true;

        function isDemoQuery(q) {
          return (q || "").trim().toLowerCase() === "demo";
        }
        
        // Senden der Frage an die aktiven Modelle
        window.sendQuestion = async function() {
          // Überprüfe zuerst das Wortlimit. Falls überschritten, wird die Funktion beendet.
          const mode = getActiveMode();
          if (!validateInputText()) {
            return;
          }
          const question = document.getElementById("questionInput").value;
          lastQuestion = question;  // Speichern in einer globalen Variable

          // === DEMO: Früh raus, wenn "Demo" ===
          if (isDemoQuery(question)) {
            // optional: Free/Deep Counter im Sidebar auf einen sicheren Dummy setzen
            document.getElementById("freeUsageDisplay").innerHTML = "Free requests: 25 / 25";
            document.getElementById("deepUsageDisplay").innerHTML = "Deep Think: 12 / 12";

            // Spinners zeigen und Demo durchspielen
            await runDemoFlow(question);
            return; // WICHTIG: keine echten API-Calls ausführen
          }
          // === DEMO: Früh raus, wenn "Demo" ===

          // clearResponseBoxes();
          consensusGenerated = false;
          if (!question) {
            alert("Please enter a question.");
            return;
          }
          
          document.getElementById("sendButton").disabled = true;
          // Konsens-Button wieder aktivieren, bevor eine neue Anfrage gesendet wird.
          document.getElementById("consensusButton").disabled = false;

          // Basis-Systemprompt laden
          const savedPrompt = localStorage.getItem("systemPrompt");

          // heutiges Datum (YYYY-MM-DD)
          const todayStr = new Date().toISOString().slice(0, 10);

          // Basis-Text, falls kein eigener Prompt gespeichert ist
          const basePrompt =
            savedPrompt ||
            "Please respond briefly and precisely, focusing only on the essentials.";

          // Prompt, der wirklich verwendet wird (immer mit Datum vorne)
          const storedSystemPrompt = `Today is ${todayStr}. ${basePrompt}`;

          let effectiveSystemPrompt = storedSystemPrompt;
          console.log("Using base system prompt:", storedSystemPrompt);

          // 🔹 ZUERST: Search/Web-Search-Status lesen
          const searchModeEnabled = document.getElementById("searchModeToggle").checked;
          const deepSearchFlag    = document.getElementById("deepSearchToggle").checked;

          // 🔹 Spinner-Basis sichern
          const baseSpinnerHTML = window.spinnerHTML;
          const webSearchSpinnerHTML = `
            <div class="thinking-wrap">
              <div class="spinner"></div>
              <span class="thinking" data-text="Web search">Web search</span>
            </div>
          `;

          // Nur Boxen der aktuell ausgewählten Modelle
          const modelBoxes = [];

          if (document.getElementById("selectOpenAI")?.checked) {
            const box = document.getElementById("openaiResponse");
            if (box) modelBoxes.push(box);
          }
          if (document.getElementById("selectMistral")?.checked) {
            const box = document.getElementById("mistralResponse");
            if (box) modelBoxes.push(box);
          }
          if (document.getElementById("selectClaude")?.checked) {
            const box = document.getElementById("claudeResponse");
            if (box) modelBoxes.push(box);
          }
          if (document.getElementById("selectGemini")?.checked) {
            const box = document.getElementById("geminiResponse");
            if (box) modelBoxes.push(box);
          }
          if (document.getElementById("selectDeepSeek")?.checked) {
            const box = document.getElementById("deepseekResponse");
            if (box) modelBoxes.push(box);
          }
          if (document.getElementById("selectGrok")?.checked) {
            const box = document.getElementById("grokResponse");
            if (box) modelBoxes.push(box);
          }

          // 🔸 PHASE 1: Während Exa-Websuche → "Web search ..."
          if (searchModeEnabled) { window.spinnerHTML = webSearchSpinnerHTML; } else { window.spinnerHTML = baseSpinnerHTML; } modelBoxes.forEach(box => setSpinnerEl(box));
          // Falls Web Search aktiv ist: einmal /prepare aufrufen
          if (searchModeEnabled) {
            try {
              // 🔹 Firebase-ID-Token holen (falls eingeloggt)
              let idToken = null;
              if (window.auth && auth.currentUser) {
                try {
                  idToken = await auth.currentUser.getIdToken();
                } catch (e) {
                  console.error("Failed to get id_token for /prepare:", e);
                }
              }

              const preparePayload = {
                question: question,
                system_prompt: storedSystemPrompt,
                search_mode: true,
                deep_search: deepSearchFlag,
                mode: mode
              };

              // Nur anhängen, wenn wirklich vorhanden
              if (idToken) {
                preparePayload.id_token = idToken;
              }

              const prepareResp = await fetch("/prepare", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(preparePayload),
                keepalive: true
              });

              const prepareData = await prepareResp.json();

              if (prepareResp.ok && prepareData.system_prompt) {
                effectiveSystemPrompt = prepareData.system_prompt;
                console.log("Using enriched system prompt from /prepare.");
              } else {
                console.warn(
                  "No enriched system_prompt from /prepare, fallback to base.",
                  prepareData
                );
              }

              window.currentEvidenceSources = prepareData.sources || [];

              // Quellen im UI anzeigen (falls Container vorhanden)
              if (prepareData.sources && window.renderEvidenceSources) {
                window.renderEvidenceSources(prepareData.sources);
              }
            } catch (err) {
              console.error("Error during /prepare:", err);
              // Fallback: effectiveSystemPrompt bleibt der gespeicherte Prompt
              window.currentEvidenceSources = [];
            }
          } else {
            // Wenn Web Search nicht aktiv ist, ggf. alte Quellen ausblenden
            if (window.renderEvidenceSources) {
              window.renderEvidenceSources([]);
            }
          }


          // 🔸 PHASE 2: Exa fertig → zurück auf "Thinking ..." für die LLMs
          window.spinnerHTML = baseSpinnerHTML;
          modelBoxes.forEach(box => setSpinnerEl(box));

          console.log("Using system prompt:", effectiveSystemPrompt);

          const deepSearchActive = document.getElementById("deepSearchToggle").checked;
  
          // Konsens-Button deaktivieren, solange noch Antworten fehlen
          const consensusBtn = document.getElementById("consensusButton");
          consensusBtn.disabled = true;
          totalRequiredResponses = 0;
  
          const openaiBox = document.getElementById("openaiResponse");
          const mistralBox = document.getElementById("mistralResponse");
          const claudeBox = document.getElementById("claudeResponse");
          const geminiBox = document.getElementById("geminiResponse");
          const deepseekBox = document.getElementById("deepseekResponse");
          const grokBox = document.getElementById("grokResponse");
          
          // Zähle nur die Modelle, die nicht als "ausgeschlossen" markiert sind
          if (!openaiBox.classList.contains("excluded")) totalRequiredResponses++;
          if (!mistralBox.classList.contains("excluded")) totalRequiredResponses++;
          if (!claudeBox.classList.contains("excluded")) totalRequiredResponses++;
          if (!geminiBox.classList.contains("excluded")) totalRequiredResponses++;
          if (!deepseekBox.classList.contains("excluded")) totalRequiredResponses++;
          if (!grokBox.classList.contains("excluded")) totalRequiredResponses++;
  
          let activeModels = [];
          if (document.getElementById("selectOpenAI").checked) activeModels.push("OpenAI");
          if (document.getElementById("selectMistral").checked) activeModels.push("Mistral");
          if (document.getElementById("selectClaude").checked) activeModels.push("Anthropic");
          if (document.getElementById("selectGemini").checked) activeModels.push("Gemini");
          if (document.getElementById("selectDeepSeek").checked) activeModels.push("DeepSeek");
          if (document.getElementById("selectGrok").checked) activeModels.push("Grok");
      
          // Spinner in den jeweiligen Response-Boxen setzen
          if (activeModels.includes("OpenAI")) {
            document.getElementById("openaiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (activeModels.includes("Mistral")) {
            document.getElementById("mistralResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (activeModels.includes("Anthropic")) {
            document.getElementById("claudeResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (activeModels.includes("Gemini")) {
            document.getElementById("geminiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (activeModels.includes("DeepSeek")) {
            document.getElementById("deepseekResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (activeModels.includes("Grok")) {
            document.getElementById("grokResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
          }
          if (document.getElementById("autoConsensusToggle").checked) {
            document.getElementById("consensusResponse").querySelector("p").innerHTML = spinnerHTML;
          } else {
            document.getElementById("consensusResponse").querySelector("p").innerHTML = "";
          }
      
          // API Keys aus localStorage abrufen
          const openaiKey = localStorage.getItem("openaiKey") || "";
          const mistralKey = localStorage.getItem("mistralKey") || "";
          const anthropicKey = localStorage.getItem("anthropicKey") || "";
          const geminiKey = localStorage.getItem("geminiKey") || "";
          const deepseekKey = localStorage.getItem("deepseekKey") || "";
          const grokKey = localStorage.getItem("grokKey") || "";
      
          let responsesReceived = 0;
          const totalActive = activeModels.length;
          function checkAllResponses() {
            responsesReceived++;
            if (responsesReceived === totalActive) {
              // Sende-Button immer wieder freischalten
              document.getElementById("sendButton").disabled = false;
              
              if (document.getElementById("autoConsensusToggle").checked) {
                // Auto Consensus ist aktiviert: 
                // Den Consensus-Button vorübergehend deaktivieren und
                // erst nach Abschluss der Konsensgenerierung wieder aktivieren.
                document.getElementById("consensusButton").disabled = true;
                getConsensus()
                  .then(() => {
                    document.getElementById("consensusButton").disabled = false;
                  })
                  .catch((error) => {
                    console.error("Fehler bei der Konsensgenerierung:", error);
                    document.getElementById("consensusButton").disabled = false;
                  });
              } else {
                // Auto Consensus nicht aktiviert – beide Buttons direkt freigeben.
                document.getElementById("consensusButton").disabled = false;
              }
            }
          }
  
        // Hilfsfunktion, um einen leeren API Key zu prüfen
        function validateUserKey(keyName) {
          const key = localStorage.getItem(keyName);
          return key && key.trim() !== "";
        }
  
        function addCopyButtons(container) {
          container.querySelectorAll('pre').forEach(function(pre) {
            // Falls bereits ein Copy-Button existiert, überspringen
            if (pre.querySelector('.copy-btn')) return;
            
            var btn = document.createElement('button');
            // Verwende ein dezentes Clipboard-Symbol
            btn.textContent = '📋';
            btn.className = 'copy-btn';
            pre.appendChild(btn);
            
            btn.addEventListener('click', function() {
              // Falls ein <code> innerhalb des <pre> existiert, kopiere dessen innerText
              var codeElement = pre.querySelector('code');
              var codeText = codeElement ? codeElement.innerText : pre.innerText;
              navigator.clipboard.writeText(codeText).then(function() {
                btn.textContent = '✓';
                setTimeout(function() {
                  btn.textContent = '📋';
                }, 2000);
              });
            });
          });
        }
  
        // Mache addCopyButtons global verfügbar:
        window.addCopyButtons = addCopyButtons;

        function addNewTabToLinks(container) {
          container.querySelectorAll('a').forEach(function(link) {
            // Falls noch kein target-Attribut gesetzt ist, füge es hinzu
            if (!link.hasAttribute('target')) {
              link.setAttribute('target', '_blank');
              link.setAttribute('rel', 'noopener noreferrer');
            }
          });
        }

        // Mache die Funktion global verfügbar:
        window.addNewTabToLinks = addNewTabToLinks;
  
        // OpenAI
        if (activeModels.includes("OpenAI")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            active_count: 1,
            search_mode: searchModeEnabled,   // oben definiert
            deep_search: deepSearchFlag,      // oben definiert
            system_prompt: effectiveSystemPrompt,
            mode: mode,
            model: document.getElementById("openaiModelSelect").value
          };

  
          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("openaiKey") || "";
            }
          } else {
            if (!validateUserKey("openaiKey")) {
              const outputEl = document.getElementById("openaiResponse").querySelector(".collapsible-content");
              outputEl.innerHTML = "Please log in or store your own API keys.";
              alert("Please enter a valid OpenAI API key.");
              return;
            }
            payload.api_key = localStorage.getItem("openaiKey");
          }
  
        fetch('/ask_openai', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          keepalive: true
        })
          .then(async (response) => {
            // Parse JSON (auch bei Non-2xx), aber werte response.ok aus
            let data = {};
            try {
              data = await response.json();
            } catch (_) {
              // keine JSON-Antwort (selten) -> leeres Objekt lassen
            }

            if (!response.ok) {
              // FastAPI gibt "detail" zurück; wir normalisieren auf eine Error-Message
              const msg =
                (data && (data.error || data.detail)) ||
                `OpenAI HTTP ${response.status}`;
              throw new Error(msg);
            }

            return data;
          })
          .then((data) => {
            const outputEl = document
              .getElementById("openaiResponse")
              .querySelector(".collapsible-content");

            if (data.response) {
              injectMarkdown(outputEl, data.response);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "OpenAI", mode);
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else if (data.detail) {
              // Falls dein Backend irgendwo noch "detail" liefert
              outputEl.innerText = data.detail;
            } else {
              outputEl.innerText = "Unexpected empty response from server.";
            }

            const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
            const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;

            document.getElementById("freeUsageDisplay").innerHTML =
              "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
            document.getElementById("deepUsageDisplay").innerHTML =
              "Deep Think: " + deepRemaining + " / 12";

            checkAllResponses();
          })
          .catch((error) => {
            const outputEl = document
              .getElementById("openaiResponse")
              .querySelector(".collapsible-content");
            // Zeig den echten Grund statt des generischen Login-Texts
            outputEl.innerText = `OpenAI error: ${error.message}`;
            console.error("Error at OpenAI:", error);
            checkAllResponses();
          });
        }
  
  
        // Mistral
        if (activeModels.includes("Mistral")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            deep_search: deepSearchFlag,
            active_count: 1,
            system_prompt: effectiveSystemPrompt,
            mode: mode,
            model: document.getElementById("mistralModelSelect").value
          };
  
          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("mistralKey") || "";
            }
          } else {
            if (!validateUserKey("mistralKey")) {
              const outputEl = document.getElementById("mistralResponse").querySelector(".collapsible-content");
              outputEl.innerHTML = "Please log in or store your own API keys.";
              alert("Please enter a valid Mistral API key.");
              return;
            }
            payload.api_key = localStorage.getItem("mistralKey");
          }
  
          fetch('/ask_mistral', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
            .then(response => response.json())
            .then(data => {
              let outputEl = document.getElementById("mistralResponse").querySelector(".collapsible-content");
              if (data.response) {
              injectMarkdown(outputEl, data.response);

                if (auth.currentUser) {
                  saveBookmark(question, data.response, "Mistral", mode);
                }
              } else if (data.error) {
                outputEl.innerText = data.error;
              } else {
                outputEl.innerText = "Please log in or store your own API keys.";
              }
              // Nutze Fallback-Werte, falls data.free_usage_remaining oder data.deep_remaining undefined sind
              const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
              const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;
              
              document.getElementById("freeUsageDisplay").innerHTML =
                "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
              document.getElementById("deepUsageDisplay").innerHTML =
                "Deep Think: " + deepRemaining + " / 12";
              checkAllResponses();
            })
            .catch(error => {
              console.error("Error with Mistral:", error);
              checkAllResponses();
            });
        }
  
        // Anthropic Claude
        if (activeModels.includes("Anthropic")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            deep_search: deepSearchFlag,
            active_count: 1,
            system_prompt: effectiveSystemPrompt,
            mode: mode,
            model: document.getElementById("claudeModelSelect").value
          };
  
          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("anthropicKey") || "";
            }
          } else {
            if (!validateUserKey("anthropicKey")) {
              const outputEl = document.getElementById("claudeResponse").querySelector(".collapsible-content");
              outputEl.innerHTML = "Please log in or store your own API keys.";
              alert("Please enter a valid Anthropic API Key.");
              return;
            }
            payload.api_key = localStorage.getItem("anthropicKey");
          }
  
          fetch('/ask_claude', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
            .then(response => response.json())
            .then(data => {
              const outputEl = document.getElementById("claudeResponse").querySelector(".collapsible-content");
              if (data.response) {
                injectMarkdown(outputEl, data.response);
                if (auth.currentUser) {
                  saveBookmark(question, data.response, "Anthropic", mode);
                }
              } else if (data.error) {
                outputEl.innerText = data.error;
              } else {
                outputEl.innerText = "Please log in or store your own API keys.";
              }
              // Nutze Fallback-Werte, falls data.free_usage_remaining oder data.deep_remaining undefined sind
              const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
              const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;
              
              document.getElementById("freeUsageDisplay").innerHTML =
                "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
              document.getElementById("deepUsageDisplay").innerHTML =
                "Deep Think: " + deepRemaining + " / 12";
              checkAllResponses();
            })
            .catch(error => {
              console.error("Error with Anthropic:", error);
              checkAllResponses();
            });
        }
  
        // Gemini
        if (activeModels.includes("Gemini")) {
            const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
            const payload = {
              question: question,
              active_count: 1,
              deep_search: deepSearchFlag,
              system_prompt: effectiveSystemPrompt,
              mode: mode,
              model: document.getElementById("geminiModelSelect").value
            };
  
            if (!useOwnKeys) {
              let id_token = localStorage.getItem("id_token");
              if (id_token) {
                payload.id_token = id_token;
              } else {
                payload.api_key = localStorage.getItem("geminiKey") || "";
              }
            } else {
              if (!validateUserKey("geminiKey")) 
              {
                const outputEl = document.getElementById("geminiResponse").querySelector(".collapsible-content");
                outputEl.innerHTML = "Please log in or store your own API keys.";
                alert("Please enter a valid Gemini API Key.");
                return;
              }
              payload.api_key = localStorage.getItem("geminiKey");
            }
  
            fetch('/ask_gemini', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
              keepalive: true
            })
            .then(response => response.json())
            .then(data => {
              const outputEl = document.getElementById("geminiResponse").querySelector(".collapsible-content");
              if (data.response) {
                injectMarkdown(outputEl, data.response);
                if (auth.currentUser) {
                  saveBookmark(question, data.response, "Gemini", mode);
                }
              } else if (data.error) {
                outputEl.innerText = data.error;
              } else {
                outputEl.innerText = "Please log in or store your own API keys.";
              }
              // Nutze Fallback-Werte, falls data.free_usage_remaining oder data.deep_remaining undefined sind
              const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
              const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;
              
              document.getElementById("freeUsageDisplay").innerHTML =
                "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
              document.getElementById("deepUsageDisplay").innerHTML =
                "Deep Think: " + deepRemaining + " / 12";
              checkAllResponses();
            })
            .catch(error => {
              console.error("Error with Gemini:", error);
              checkAllResponses();
            });
        }
  
        // DeepSeek
        if (activeModels.includes("DeepSeek")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            deep_search: deepSearchFlag,
            active_count: 1,
            system_prompt: effectiveSystemPrompt,
            mode: mode,
            model: document.getElementById("deepseekModelSelect").value
          };
  
          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("deepseekKey") || "";
            }
          } else {
            if (!validateUserKey("deepseekKey")) {
              const outputEl = document.getElementById("deepseekResponse").querySelector(".collapsible-content");
              outputEl.innerHTML = "Please log in or store your own API keys.";
              alert("Please enter a valid DeepSeek API key.");
              return;
            }
            payload.api_key = localStorage.getItem("deepseekKey");
          }
  
          fetch('/ask_deepseek', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
            .then(response => response.json())
            .then(data => {
              const outputEl = document.getElementById("deepseekResponse").querySelector(".collapsible-content");
              if (data.response) {
                injectMarkdown(outputEl, data.response);
                if (auth.currentUser) {
                  saveBookmark(question, data.response, "DeepSeek", mode);
                }
              } else if (data.error) {
                outputEl.innerText = data.error;
              } else {
                outputEl.innerText = "Please log in or store your own API keys.";
              }
              // Nutze Fallback-Werte, falls data.free_usage_remaining oder data.deep_remaining undefined sind
              const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
              const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;
              
              document.getElementById("freeUsageDisplay").innerHTML =
                "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
              document.getElementById("deepUsageDisplay").innerHTML =
                "Deep Think: " + deepRemaining + " / 12";
              checkAllResponses();
            })
            .catch(error => {
              console.error("Fehler bei DeepSeek:", error);
              checkAllResponses();
            });
        }
  
        // Grok
        if (activeModels.includes("Grok")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            deep_search: deepSearchFlag,
            active_count: 1,
            system_prompt: effectiveSystemPrompt,
            mode: mode,
            model: document.getElementById("grokModelSelect").value
          };

          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("grokKey") || "";
            }
          } else {
            if (!validateUserKey("grokKey")) {
              const outputEl = document.getElementById("grokResponse").querySelector(".collapsible-content");
              outputEl.innerHTML = "Please log in or store your own API keys.";
              alert("Please enter a valid Grok API key.");
              return;
            }
            payload.api_key = localStorage.getItem("grokKey");
          }
          fetch('/ask_grok', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            keepalive: true
          })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("grokResponse").querySelector(".collapsible-content");
            if (data.response) {
              injectMarkdown(outputEl, data.response);
              if (auth.currentUser) {
                saveBookmark(question, data.response, "Grok", mode);
              }
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Please log in or store your own API keys.";
            }
            // Nutze Fallback-Werte, falls data.free_usage_remaining oder data.deep_remaining undefined sind
            const freeRemaining = (data.free_usage_remaining !== undefined) ? data.free_usage_remaining : 0;
            const deepRemaining = (data.deep_remaining !== undefined) ? data.deep_remaining : 0;
            
            document.getElementById("freeUsageDisplay").innerHTML =
              "Free requests: " + freeRemaining + " / " + FREE_USAGE_LIMIT;
            document.getElementById("deepUsageDisplay").innerHTML =
              "Deep Think: " + deepRemaining + " / 12";
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei Grok:", error);
            checkAllResponses();
          });
        }
      };
      
        // Modelle (Checkboxen) ein-/ausschalten
        window.toggleModel = function(responseId, isChecked) {
          const box = document.getElementById(responseId);
          if (!isChecked) {
            box.classList.add("excluded");
          } else {
            box.classList.remove("excluded");
          }
        };
        document.getElementById("selectOpenAI").addEventListener("change", function() {
          toggleModel("openaiResponse", this.checked);
        });
        document.getElementById("selectMistral").addEventListener("change", function() {
          toggleModel("mistralResponse", this.checked);
        });
        document.getElementById("selectClaude").addEventListener("change", function() {
          toggleModel("claudeResponse", this.checked);
        });
        document.getElementById("selectGemini").addEventListener("change", function() {
          toggleModel("geminiResponse", this.checked);
        });
        document.getElementById("selectDeepSeek").addEventListener("change", function() {
          toggleModel("deepseekResponse", this.checked);
        });
        document.getElementById("selectGrok").addEventListener("change", function() {
          toggleModel("grokResponse", this.checked);
        });

        // Modell-Dropdowns aktualisieren die angezeigten Namen
        document.getElementById("openaiModelSelect").addEventListener("change", function() {
          document.getElementById("openaiModelText").textContent = this.value;
        });
        document.getElementById("mistralModelSelect").addEventListener("change", function() {
          document.getElementById("mistralModelText").textContent = this.value;
        });
        document.getElementById("claudeModelSelect").addEventListener("change", function() {
          document.getElementById("claudeModelText").textContent = this.value;
        });
        document.getElementById("geminiModelSelect").addEventListener("change", function() {
          document.getElementById("geminiModelText").textContent = this.value;
        });
        document.getElementById("deepseekModelSelect").addEventListener("change", function() {
          document.getElementById("deepseekModelText").textContent = this.value;
        });
        document.getElementById("grokModelSelect").addEventListener("change", function() {
          document.getElementById("grokModelText").textContent = this.value;
        });

        // collapse model dropdown after selection to avoid lingering focus
        document.querySelectorAll('.model-picker').forEach(function(sel) {
          sel.addEventListener('change', function() {
            this.blur();
          });
        });
      
        // Erneut API Keys in Felder schreiben (falls benötigt)
        ["openaiKey", "mistralKey", "anthropicKey", "geminiKey", "deepseekKey", "grokKey"].forEach(function(key) {
          const stored = localStorage.getItem(key);
          if (stored) {
            document.getElementById(key).value = stored;
          }
        });
  
      // Search Mode Toggle: Modelle automatisch anpassen, wenn aktiviert
      //const searchModeToggle = document.getElementById("searchModeToggle");
      //const searchDisclaimer = document.getElementById("searchDisclaimer");
  
      function showDisclaimerPopup() {
        const popup = document.getElementById('disclaimerPopup');
        popup.classList.add('show');
        // Popup nach 3 Sekunden wieder ausblenden
        setTimeout(() => {
          popup.classList.remove('show');
        }, 5000);
      }
  
      searchModeToggle.addEventListener("change", function() {
        const isSearchMode = this.checked;
        consensusDropdown.disabled = false;

        // 4) DeepThink-Text / Hinweis aktualisieren (damit Web Search Text passt)
        updateDeepThinkText();
      });
      
        // Globale Variable, um die letzte verarbeitete Frage zu speichern.
        let lastQuestion = "";
  
        window.getConsensus = async function() {
          const question =
            (document.getElementById("questionInput")?.value ?? lastQuestion ?? "")
              .trim();
            // Status, ob eigene API Keys genutzt werden sollen
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          let searchMode = document.getElementById("searchModeToggle").checked;
          
          // Nur im Gratis-Modus id_token abrufen
          const id_token = useOwnKeys ? null : localStorage.getItem("id_token");
  
          // Wenn die Frage neu oder geändert ist, werden Firebase-Votes aktualisiert.
          if (question !== lastQuestion) {
            // Für jedes Modell prüfen, ob es als "best" markiert ist.
            if (document.getElementById("openaiResponse").classList.contains("best")) {
              recordModelVote("OpenAI", "best");
            }
            if (document.getElementById("mistralResponse").classList.contains("best")) {
              recordModelVote("Mistral", "best");
            }
            if (document.getElementById("claudeResponse").classList.contains("best")) {
              recordModelVote("Anthropic", "best");
            }
            if (document.getElementById("geminiResponse").classList.contains("best")) {
              recordModelVote("Gemini", "best");
            }
            if (document.getElementById("deepseekResponse").classList.contains("best")) {
              recordModelVote("DeepSeek", "best");
            }
            if (document.getElementById("grokResponse").classList.contains("best")) {
              recordModelVote("Grok", "best");
            }
  
            // Ebenso für "excluded" (sofern du das separat erfassen möchtest).
            if (document.getElementById("openaiResponse").classList.contains("excluded")) {
              recordModelVote("OpenAI", "exclude");
            }
            if (document.getElementById("mistralResponse").classList.contains("excluded")) {
              recordModelVote("Mistral", "exclude");
            }
            if (document.getElementById("claudeResponse").classList.contains("excluded")) {
              recordModelVote("Anthropic", "exclude");
            }
            if (document.getElementById("geminiResponse").classList.contains("excluded")) {
              recordModelVote("Gemini", "exclude");
            }
            if (document.getElementById("deepseekResponse").classList.contains("excluded")) {
              recordModelVote("DeepSeek", "exclude");
            }
            if (document.getElementById("grokResponse").classList.contains("excluded")) {
              recordModelVote("Grok", "exclude");
            }
  
            // Aktualisiere die letzte verarbeitete Frage.
            lastQuestion = question;
          }
  
          // Setze den Konsens-Bereich (Spinner etc.) und rufe anschließend deinen Konsens-Endpunkt auf.
          const consensusDiv = document.getElementById("consensusResponse");
          const mainSpinner = window.spinnerHTML;
          const diffSpinner = window.spinnerHTML;
  
          consensusDiv.querySelector(".consensus-main p").innerHTML = mainSpinner;
          consensusDiv.querySelector(".consensus-differences p").innerHTML = diffSpinner;
  
        const consensus_model = document.getElementById("consensusModelDropdown").value;
  
        // Hole die Antwort-Boxen
        const openaiBox = document.getElementById("openaiResponse");
        const mistralBox = document.getElementById("mistralResponse");
        const claudeBox = document.getElementById("claudeResponse");
        const geminiBox = document.getElementById("geminiResponse");
        const deepseekBox = document.getElementById("deepseekResponse");
        const grokBox = document.getElementById("grokResponse");
  
        // Lies die Antworten (trim für überflüssige Leerzeichen)
        const answer_openai = openaiBox.querySelector(".collapsible-content").innerText.trim();
        const answer_mistral = mistralBox.querySelector(".collapsible-content").innerText.trim();
        const answer_claude = claudeBox.querySelector(".collapsible-content").innerText.trim();
        const answer_gemini = geminiBox.querySelector(".collapsible-content").innerText.trim();
        const answer_deepseek = deepseekBox.querySelector(".collapsible-content").innerText.trim();
        const answer_grok = grokBox.querySelector(".collapsible-content").innerText.trim();
  
        // Überprüfe nur die Modelle, die nicht als "ausgeschlossen" markiert sind.
        // Überprüfe nur Modelle, die im jeweiligen Modus relevant UND nicht "excluded" sind.
        const needOpenAI       = !searchMode && !openaiBox.classList.contains("excluded");
        const needGemini       = !searchMode && !geminiBox.classList.contains("excluded");
        const needMistral      = !searchMode && !mistralBox.classList.contains("excluded");
        const needClaude       = !searchMode && !claudeBox.classList.contains("excluded");
        const needDeepseek     = !searchMode && !deepseekBox.classList.contains("excluded");
        const needGrok         = !searchMode && !grokBox.classList.contains("excluded");

        if (
          !question ||
          !consensus_model ||
          (needOpenAI     && !answer_openai)       ||
          (needGemini     && !answer_gemini)       ||
          (needMistral    && !answer_mistral)      ||
          (needClaude     && !answer_claude)       ||
          (needDeepseek   && !answer_deepseek)     ||
          (needGrok       && !answer_grok)
        ) {
          alert("Refresh the page. Please send a question first, retrieve all answers and select the consensus model.");
          return;
        }
  
        // Hole den best markierten Modus (falls vorhanden)
        const bestBox = document.querySelector(".response-box.best");
        let best_model = bestBox ? bestBox.getAttribute("data-model") : "";
  
        // Die übrigen Parameter wie "excluded_models" werden wie bisher ermittelt
        const excludedModels = [];
        if (openaiBox.classList.contains("excluded")) {
          excludedModels.push(openaiBox.getAttribute("data-model"));
        }
        if (mistralBox.classList.contains("excluded")) {
          excludedModels.push(mistralBox.getAttribute("data-model"));
        }
        if (claudeBox.classList.contains("excluded")) {
          excludedModels.push(claudeBox.getAttribute("data-model"));
        }
        if (geminiBox.classList.contains("excluded")) {
          excludedModels.push(geminiBox.getAttribute("data-model"));
        }
        if (deepseekBox.classList.contains("excluded")) {
          excludedModels.push(deepseekBox.getAttribute("data-model"));
        }
        if (grokBox.classList.contains("excluded")) {
          excludedModels.push(grokBox.getAttribute("data-model"));
        }
  
        // Hole API Keys aus localStorage
        const openaiKey = localStorage.getItem("openaiKey") || "";
        const mistralKey = localStorage.getItem("mistralKey") || "";
        const anthropicKey = localStorage.getItem("anthropicKey") || "";
        const geminiKey = localStorage.getItem("geminiKey") || "";
        const deepseekKey= localStorage.getItem("deepseekKey") || "";
        const grokKey= localStorage.getItem("grokKey") || "";

        // --------- NEU: genaue Konsensus-Metadaten für Zitation speichern ---------
        const includedModelsDetailed = [];

        function addModelForCitation(boxId, selectId, label) {
          const box = document.getElementById(boxId);
          if (!box) return;
          if (box.classList.contains("excluded")) return;

          const contentEl = box.querySelector(".collapsible-content");
          const text = contentEl ? contentEl.innerText.trim() : "";
          if (!text) return; // nur Modelle mit Antwort

          const select = document.getElementById(selectId);
          let modelName = "";
          if (select) {
            const val = select.value || "";
            const optText = select.options[select.selectedIndex]?.text || "";
            modelName = optText || val;
          }

          includedModelsDetailed.push(modelName ? `${label}: ${modelName}` : label);
        }

        addModelForCitation("openaiResponse",  "openaiModelSelect",  "OpenAI");
        addModelForCitation("mistralResponse", "mistralModelSelect", "Mistral");
        addModelForCitation("claudeResponse",  "claudeModelSelect",  "Anthropic Claude");
        addModelForCitation("geminiResponse",  "geminiModelSelect",  "Google Gemini");
        addModelForCitation("deepseekResponse","deepseekModelSelect","DeepSeek");
        addModelForCitation("grokResponse",    "grokModelSelect",    "Grok");

        const consensusSelect = document.getElementById("consensusModelDropdown");
        const consensusModelValue = consensusSelect ? consensusSelect.value : "";
        const consensusModelLabel = consensusSelect
          ? (consensusSelect.options[consensusSelect.selectedIndex]?.text || consensusModelValue)
          : consensusModelValue;

        // URL für die Zitation „aufgeräumt“
        let cleanUrl = window.location.href;
        try {
          const urlObj = new URL(window.location.href);
          cleanUrl = urlObj.origin + urlObj.pathname;
        } catch (e) {
          // falls URL-Parsing scheitert, nimm einfach href
        }

        window.consensusCitationMeta = {
          question,
          includedModels: includedModelsDetailed,
          consensusModel: consensusModelLabel || consensusModelValue,
          dateISO: new Date().toISOString(),
          url: cleanUrl
        };
        // --------- ENDE NEU ------------------------------------------------------
  
        try {
          const response = await fetch("/consensus", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              id_token: id_token,
              useOwnKeys: useOwnKeys,
              question: question,
              search_mode: searchMode,
              answer_openai: answer_openai,
              answer_mistral: answer_mistral,
              answer_claude: answer_claude,
              answer_gemini: answer_gemini,
              answer_deepseek: answer_deepseek,
              answer_grok: answer_grok,
              best_model: best_model,
              consensus_model: consensus_model,
              excluded_models: excludedModels,
              openai_key: openaiKey,
              mistral_key: mistralKey,
              anthropic_key: anthropicKey,
              gemini_key: geminiKey,
              deepseek_key: deepseekKey,
              grok_key: grokKey,
              keepalive: true
            })
          });
          const data = await response.json();

          // Aktualisiere Free Requests, falls vorhanden (Deep Think nicht benötigt)
          if (data.free_usage_remaining !== undefined) {
            document.getElementById("freeUsageDisplay").innerText =
              "Free requests: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
          }

          if (response.ok) {
            const mainEl = consensusDiv.querySelector(".consensus-main p");
            const diffEl = consensusDiv.querySelector(".consensus-differences p");

            if (mainEl) {
              // Konsens-Text inkl. [S1]-Links, Copy-Buttons usw.
              injectMarkdown(mainEl, data.consensus_response);
            }

            if (diffEl) {
              const diffsMD = data.differences || "No differences found.";
              const colored = window.colorizeCredibility
                ? window.colorizeCredibility(diffsMD)
                : diffsMD;

              // Differences auch über injectMarkdown → [S1]-Links inkl.
              injectMarkdown(diffEl, colored);
            }

            if (auth.currentUser) {
              saveBookmarkConsensus(question, data.consensus_response, data.differences);
            }

            const bestModelFromConsensus = parseBestModel(data.differences);
            if (bestModelFromConsensus) {
              recordModelVote(bestModelFromConsensus, "BestModel");
            }
          } else {
            consensusDiv.querySelector(".consensus-main p").innerText = "Error: " + data.detail;
            consensusDiv.querySelector(".consensus-differences p").innerText = "";
          }

        } catch (error) {
          console.error("Error fetching consensus:", error);
          consensusDiv.querySelector(".consensus-main p").innerText = "Error in the consensus calculation.";
          consensusDiv.querySelector(".consensus-differences p").innerText = "";
        }
      };
      
        // Testet die API Keys und aktualisiert das Feedback
        window.testAllKeys = async function() {
          const openaiKey = document.getElementById("openaiKey").value;
          const mistralKey = document.getElementById("mistralKey").value;
          const anthropicKey = document.getElementById("anthropicKey").value;
          const geminiKey = document.getElementById("geminiKey").value;
          const deepseekKey = document.getElementById("deepseekKey").value;
          const grokKey = document.getElementById("grokKey").value;
          localStorage.setItem("openaiKey", openaiKey);
          localStorage.setItem("mistralKey", mistralKey);
          localStorage.setItem("anthropicKey", anthropicKey);
          localStorage.setItem("geminiKey", geminiKey);
          localStorage.setItem("deepseekKey", deepseekKey);
          localStorage.setItem("grokKey", grokKey);
          const spinner = document.getElementById("apiSpinner");
          spinner.style.display = "inline-block";
          try {
            const response = await fetch("/check_keys", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                openai_key: openaiKey,
                mistral_key: mistralKey,
                anthropic_key: anthropicKey,
                gemini_key: geminiKey,
                deepseek_key: deepseekKey,
                grok_key: grokKey
              })
            });
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(errorText);
            }
            const data = await response.json();
            console.log("Response von /check_keys:", data);
            if (!data || !data.results) {
              throw new Error("The response does not contain a 'results' object. Response: " + JSON.stringify(data));
            }
            const openaiResult = data.results["OpenAI"];
            const mistralResult = data.results["Mistral"];
            const anthropicResult = data.results["Anthropic"];
            const geminiResult = data.results["Gemini"];
            const deepseekResult = data.results["DeepSeek"];
            const grokResult = data.results["Grok"];
            const openaiFeedback = document.getElementById("openaiFeedback");
            const mistralFeedback = document.getElementById("mistralFeedback");
            const anthropicFeedback = document.getElementById("anthropicFeedback");
            const geminiFeedback = document.getElementById("geminiFeedback");
            const deepseekFeedback = document.getElementById("deepseekFeedback");
            const grokFeedback = document.getElementById("grokFeedback");
            openaiFeedback.innerHTML = openaiResult === "valid" ? "&#9734;" : "&#10007;";
            openaiFeedback.style.color = openaiResult === "valid" ? "green" : "red";
            mistralFeedback.innerHTML = mistralResult === "valid" ? "&#9734;" : "&#10007;";
            mistralFeedback.style.color = mistralResult === "valid" ? "green" : "red";
            anthropicFeedback.innerHTML = anthropicResult === "valid" ? "&#9734;" : "&#10007;";
            anthropicFeedback.style.color = anthropicResult === "valid" ? "green" : "red";
            geminiFeedback.innerHTML = geminiResult === "valid" ? "&#9734;" : "&#10007;";
            geminiFeedback.style.color = geminiResult === "valid" ? "green" : "red";
            deepseekFeedback.innerHTML = deepseekResult === "valid" ? "&#9734;" : "&#10007;";
            deepseekFeedback.style.color = deepseekResult === "valid" ? "green" : "red";
            grokFeedback.innerHTML = grokResult === "valid" ? "&#9734;" : "&#10007;";
            grokFeedback.style.color = grokResult === "valid" ? "green" : "red";
          } catch (error) {
            console.error("Fehler beim Testen der API Keys:", error);
            alert("Fehler beim Testen der API Keys: " + error.message);
          } finally {
            spinner.style.display = "none";
          }
        };

        const feedbackForm = document.getElementById("feedbackForm");
          if (feedbackForm) {
            feedbackForm.addEventListener("submit", function(e) {
              e.preventDefault();
              const message = this.elements["message"].value;
              const email = this.elements["email"].value;
              // Hier rufen wir die neue sendFeedback-Funktion auf, die den Backend-Endpoint nutzt.
              window.sendFeedback(message, email)
                .then(data => {
                  if(data.status === "success"){
                    this.reset();
                    alert("Feedback gesendet!");
                  } else {
                    alert("Fehler: " + data.detail);
                  }
                })
                .catch(error => {
                  console.error("Fehler beim Speichern des Feedbacks:", error);
                  alert("Fehler beim Speichern des Feedbacks: " + error.message);
                });
            });
          }

        window.clearResponseBoxes = function() {
          const boxIds = [
            "openaiResponse",
            "mistralResponse",
            "claudeResponse",
            "geminiResponse",
            "deepseekResponse",
            "grokResponse"
          ];
          
          // Deaktiviere den Consensus-Button, sofern nötig.
          document.getElementById("consensusButton").disabled = true;
          
          // Lösche den Inhalt aller Modell-Antwortboxen.
          boxIds.forEach(id => {
            const box = document.getElementById(id);
            if (box) {
              const contentEl = box.querySelector(".collapsible-content");
              if (contentEl) {
                contentEl.innerHTML = "";
              }
            }
          });
          
          // Leere den Inhalt der Consensus-Antwortbox.
          const consensusBox = document.getElementById("consensusResponse");
          if (consensusBox) {
            const mainElement = consensusBox.querySelector(".consensus-main p");
            if (mainElement) {
              mainElement.innerHTML = "";
            }
            
            const diffElement = consensusBox.querySelector(".consensus-differences p");
            if (diffElement) {
              diffElement.innerHTML = "";
            }
          }

          // Leere den Inhalt der Input-Box mit der ID "questionInput".
          const inputBox = document.getElementById("questionInput");
          if (inputBox) {
            inputBox.value = "";
          }
        }

        function getActiveMode() {
          const deepSearchActive = document.getElementById("deepSearchToggle").checked;
          const searchModeActive = document.getElementById("searchModeToggle").checked;
          
          // Beispielhafte Logik: Priorisiere Deep Think, falls aktiviert:
          if (deepSearchActive) {
            return "Deep Think";
          } else if (searchModeActive) {
            return "Web Search";
          }
          return "Standard"; // Default-Wert, falls keine Checkbox aktiviert ist
        }

        function updateCountdown() {
          // Aktuelles Datum und Uhrzeit
          const now = new Date();
          
          // Erstelle ein Datum für heute um 00:15
          let resetTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 15, 0, 0);
          
          // Falls aktuelle Zeit bereits nach 00:15 liegt, setze resetTime auf morgen um 00:15
          if (now >= resetTime) {
            resetTime.setDate(resetTime.getDate() + 1);
          }
          
          // Differenz in Millisekunden bis zur festgelegten Reset-Zeit (00:15)
          const diff = resetTime - now;
          
          // Berechne Stunden, Minuten und Sekunden
          const hours = Math.floor(diff / (1000 * 60 * 60));
          const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((diff % (1000 * 60)) / 1000);
          
          // Formatieren mit führenden Nullen
          const formattedHours = hours.toString().padStart(2, "0");
          const formattedMinutes = minutes.toString().padStart(2, "0");
          const formattedSeconds = seconds.toString().padStart(2, "0");
          
          // Ausgabe im HTML-Element aktualisieren
          document.getElementById('countdownDisplay').innerHTML =
            "Resets in: " + formattedHours + ":" + formattedMinutes + ":" + formattedSeconds;
          
          // Wenn der Countdown abgelaufen ist, wird der Server (oder die Seite) neu gestartet
          if (diff <= 0) {
            location.reload(); // Hier kann auch ein anderer Reset-Mechanismus aufgerufen werden
          }
        }

        // Countdown sofort starten und jede Sekunde aktualisieren
        updateCountdown();
        setInterval(updateCountdown, 1000);

        document.getElementById("logoLink").addEventListener("click", () => {
          // wenn ich wirklich zurück will, entferne den visitedLanding-Flag
          localStorage.removeItem("visitedLanding");
          // und damit gilt beim nächsten Laden der Landing-Seite wieder first-view
        });

        // Demo-Chip automatisch beim ersten echten Besuch (wenn noch nie benutzt)
        if (!localStorage.getItem("marketingPopupShown") || !localStorage.getItem("demoChipDismissed")) {
          createStartDemoChip();
        }

                // -----------------------------------
        // Consensus: Copy Answer & Copy Citation
        // -----------------------------------

        function getIncludedModelNamesForCitation() {
          const map = [
            { boxId: "openaiResponse",  label: "OpenAI" },
            { boxId: "mistralResponse", label: "Mistral" },
            { boxId: "claudeResponse",  label: "Anthropic Claude" },
            { boxId: "geminiResponse",  label: "Google Gemini" },
            { boxId: "deepseekResponse",label: "DeepSeek" },
            { boxId: "grokResponse",    label: "Grok" }
          ];

          const names = [];
          map.forEach(({ boxId, label }) => {
            const box = document.getElementById(boxId);
            if (!box) return;
            if (box.classList.contains("excluded")) return;

            const txtEl = box.querySelector(".collapsible-content");
            const txt = txtEl ? txtEl.innerText.trim() : "";
            if (txt) {
              names.push(label);
            }
          });

          return names;
        }

        function buildConsensusCitation() {
          const meta = window.consensusCitationMeta;

          // Noch kein Consensus berechnet → keine Zitation
          if (!meta || !meta.includedModels || !meta.includedModels.length) {
            return "";
          }

          const date = meta.dateISO ? new Date(meta.dateISO) : new Date();
          const yyyy = date.getFullYear();
          const mm = String(date.getMonth() + 1).padStart(2, "0");
          const dd = String(date.getDate()).padStart(2, "0");
          const dateStr = `${yyyy}-${mm}-${dd}`;

          const question       = (meta.question || "").trim();
          const modelsPart     = meta.includedModels.join(", ");
          const consensusModel = meta.consensusModel || "";
          const cleanUrl       = meta.url || window.location.href;

          const parts = [];

          // „Autor“ / Seite + Datum
          parts.push(`consens.io. (${dateStr}).`);

          // „Titel“
          if (question) {
            parts.push(`Consensus answer to "${question}".`);
          } else {
            parts.push("Consensus answer.");
          }

          // Modelle genau wie genutzt
          parts.push(`Models consulted: ${modelsPart}.`);

          // Consensus-Modell
          if (consensusModel) {
            parts.push(`Consensus model: ${consensusModel}.`);
          }

          // --- NEU: Links aus der Consensus-Antwort einsammeln ---
          const consensusBox = document.getElementById("consensusResponse");
          const mainPara = consensusBox?.querySelector(".consensus-main p");

          const hrefSet = new Set();
          if (mainPara) {
            mainPara.querySelectorAll("a[href]").forEach(a => {
              const href = a.getAttribute("href");
              if (!href) return;
              // interne Anker (#foo) ignorieren
              if (href.startsWith("#")) return;
              hrefSet.add(href);
            });
          }

          const links = Array.from(hrefSet);
          if (links.length) {
            parts.push(`Sources: ${links.join(", ")}`);
          }
          // --- ENDE NEU ---

          // Seite selbst
          parts.push(`Retrieved from ${cleanUrl}`);

          // Eine Zeile, keine Zeilenumbrüche
          return parts.join(" ");
        }

        let consensusMenuEl = null;

        function ensureConsensusActionsMenu() {
          if (consensusMenuEl) return consensusMenuEl;

          const menu = document.createElement("div");
          menu.id = "consensusActionsMenuGlobal";
          menu.className = "consensus-actions-menu";

          // 📋 Copy consensus
          const copyAnswerBtn = document.createElement("button");
          copyAnswerBtn.type = "button";
          copyAnswerBtn.className = "consensus-copy-icon-btn consensus-copy-btn";
          copyAnswerBtn.innerHTML = `
            <span class="copy-icon" aria-hidden="true"></span>
            <span class="copy-label">Copy consensus</span>
          `;
          copyAnswerBtn.title = "Copy consensus answer";

          copyAnswerBtn.addEventListener("click", () => {
            const consensusBox = document.getElementById("consensusResponse");
            const mainPara = consensusBox?.querySelector(".consensus-main p");
            const mainText = mainPara ? mainPara.innerText.trim() : "";

            if (!mainText) {
              alert("No consensus available yet.");
              return;
            }

            const toCopy = mainText;

            if (!navigator.clipboard) {
              const ta = document.createElement("textarea");
              ta.value = toCopy;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand("copy");
              document.body.removeChild(ta);
              showPopup("Consensus copied to clipboard.");
            } else {
              navigator.clipboard.writeText(toCopy).then(() => {
                showPopup("Consensus copied to clipboard.");
              }).catch(() => {
                alert("Copy to clipboard failed.");
              });
            }
          });

          // 📎 Copy citation
          const copyCitationBtn = document.createElement("button");
          copyCitationBtn.type = "button";
          copyCitationBtn.className = "consensus-copy-icon-btn consensus-citation-btn";
          copyCitationBtn.innerHTML = `
            <span class="copy-icon" aria-hidden="true"></span>
            <span class="copy-label">Copy citation</span>
          `;
          copyCitationBtn.title = "Copy consensus citation";

          copyCitationBtn.addEventListener("click", () => {
            const citation = buildConsensusCitation();

            if (!citation) {
              alert("No citation available yet.");
              return;
            }

            if (!navigator.clipboard) {
              const ta = document.createElement("textarea");
              ta.value = citation;
              document.body.appendChild(ta);
              ta.select();
              document.execCommand("copy");
              document.body.removeChild(ta);
              showPopup("Citation copied to clipboard.");
            } else {
              navigator.clipboard.writeText(citation).then(() => {
                showPopup("Citation copied to clipboard.");
              }).catch(() => {
                alert("Copy to clipboard failed.");
              });
            }
          });

          menu.appendChild(copyAnswerBtn);
          menu.appendChild(copyCitationBtn);
          document.body.appendChild(menu);

          consensusMenuEl = menu;
          return menu;
        }

        function initConsensusCopyButtons() {
          const consensusBox = document.getElementById("consensusResponse");
          if (!consensusBox) return;

          const mainSection = consensusBox.querySelector(".consensus-main");
          if (!mainSection) return;

          const heading = mainSection.querySelector("h2");
          if (!heading) return;

          // Nicht doppelt einfügen
          if (heading.querySelector(".consensus-copy-inline")) return;

          // Container direkt im H2 (steht neben "Consensus Answer")
          const inlineBar = document.createElement("span");
          inlineBar.className = "consensus-copy-inline";

          // Wrapper im Pill-Look
          const actionsWrapper = document.createElement("div");
          actionsWrapper.className = "consensus-actions-wrapper";

          // Sichtbarer Trigger: NUR Icon + Caret, KEINE Beschriftung
          const toggleBtn = document.createElement("button");
          toggleBtn.type = "button";
          toggleBtn.className = "consensus-actions-toggle";
          toggleBtn.setAttribute("aria-label", "Copy options");
          toggleBtn.innerHTML = `
            <span class="copy-icon" aria-hidden="true"></span>
            <span class="caret">▾</span>
          `;

          actionsWrapper.appendChild(toggleBtn);
          inlineBar.appendChild(actionsWrapper);
          heading.appendChild(inlineBar);

          const menu = ensureConsensusActionsMenu();

          function closeMenu() {
            if (!menu) return;
            menu.classList.remove("open");
            menu.style.display = "none";
            actionsWrapper.classList.remove("open");
          }

          function openMenu() {
            // evtl. vorher schließen (falls irgendwann mehrere Trigger …)
            closeMenu();

            // anzeigen, aber unsichtbar, um Breite zu messen
            menu.style.display = "block";
            menu.style.visibility = "hidden";
            menu.classList.add("open");
            actionsWrapper.classList.add("open");

            const rect = toggleBtn.getBoundingClientRect();
            const menuWidth = menu.offsetWidth || 180;

            const top = rect.bottom + 6; // 6px unter dem Button
            let left = rect.right - menuWidth; // rechtsbündig unter dem Button
            left = Math.max(8, left);          // nicht komplett aus dem Viewport schieben

            menu.style.top = `${top}px`;
            menu.style.left = `${left}px`;
            menu.style.visibility = "visible";
          }

          toggleBtn.addEventListener("click", (evt) => {
            evt.stopPropagation();
            const isOpen = menu.classList.contains("open");
            if (isOpen) {
              closeMenu();
            } else {
              openMenu();
            }
          });

          // Klick außerhalb schließt das Menü
          document.addEventListener("click", (evt) => {
            if (!menu.classList.contains("open")) return;
            if (menu.contains(evt.target) || actionsWrapper.contains(evt.target)) return;
            closeMenu();
          });

          // Bei Scroll / Resize schließen, damit es nicht „in der Luft“ hängt
          window.addEventListener("scroll", () => {
            if (menu.classList.contains("open")) closeMenu();
          }, { passive: true });

          window.addEventListener("resize", () => {
            if (menu.classList.contains("open")) closeMenu();
          });
        }

        // am Ende deines DOMContentLoaded-Blocks aufrufen:
        initConsensusCopyButtons();

      });

</script>

<!-- Login Modal -->
<div id="loginModal" class="modal">
  <div class="modal-content" id="loginModalContent">
    <span class="close" id="closeLoginModal">&times;</span>

    <!-- Brand (inline styles) -->
    <div style="display:flex; align-items:center; justify-content:center; gap:10px; margin:8px 0 10px;">
      <img src="/static/favicon.png" alt="consens.io"
           style="width:28px; height:28px; border-radius:6px; display:block;" />
      <span style="font-size:1.15rem; font-weight:200; letter-spacing:.2px; opacity:.95;">
        consens.io
      </span>
    </div>
    </br>
    <h2 id="authTitle" style="margin:6px 0 4px; font-size:1.15rem;">Login</h2>
    <!-- Das Login-Formular hat autocomplete="on" -->
    <form id="loginForm" autocomplete="on" data-mode="login">
      
      <!-- Login / shared fields -->
      <input type="email" id="loginEmail" name="email" placeholder="Email" autocomplete="username" />

      <!-- Confirm email (register-only) -->
      <input
        type="email"
        id="loginEmailConfirm"
        name="email_confirm"
        placeholder="Confirm Email"
        autocomplete="username"
        style="display:none;"
      />

      <input
        type="password"
        id="loginPassword"
        name="password"
        placeholder="Password"
        autocomplete="current-password"
      />

      <!-- Confirm password (register-only) -->
      <input
        type="password"
        id="loginPasswordConfirm"
        name="password_confirm"
        placeholder="Confirm Password"
        autocomplete="new-password"
        style="display:none;"
      />

      <!-- Primary actions -->
      <div style="display:flex; gap:10px; align-items:center; margin-top:15px;">
        <button type="button" id="loginButton">Log in</button>
        <button type="button" id="confirmRegisterButton" style="display:none;">Create account</button>
      </div>
      
      <!-- Inline errors -->
      <div id="loginError" class="error-message" style="margin-top:8px;"></div>
      <div id="registerError" class="error-message" style="margin-top:4px;"></div>

      <div id="singleMailNote"
          style="font-size:.8rem; color:#6b7280; text-align:center; margin:2px auto 10px; max-width:280px; line-height:1.35;">
        Important: Only one e-mail can be registered
      </div>
      </br>

      <style>
        #loginForm[data-mode="register"] #singleMailNote { display:block !important; }
        #loginForm[data-mode="register"] #forgotPasswordButton { visibility:hidden; }
        #singleMailNote { display:none !important; }
      </style>

      <!-- Secondary row (links only) -->
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
      <a href="#" id="forgotPasswordButton" class="secondary-link">Forgot Password?</a>
      <button type="button" id="toggleRegister" class="link-btn secondary-link">
        New here? Create account
      </button>
      </div></br>

      <!-- Subtle divider -->
      <div id="oauthDivider" style="height:1px; background:#e5e7eb; margin:12px 0 10px;"></div>
    </br>
      <!-- Google OAuth Button (full width) -->
      <button
        type="button"
        id="googleLoginButton"
        aria-label="Continue with Google"
        style="
          width:95%;
          margin: left 9px;
          display:flex; align-items:center; justify-content:center; gap:10px;
          padding:10px 12px; border:1px solid #e5e7eb; border-radius:10px;
          background:#ffffff; box-shadow:0 1px 2px rgba(0,0,0,0.04);
          font-size:0.95rem; line-height:1; color:#111827;
          cursor:pointer; transition:background .15s ease, box-shadow .15s ease, transform .02s ease;
          user-select:none;
        "
      >
        <img src="/static/icons/google.png" alt="" width="18" height="18" style="display:block;" />
        <span style="white-space:nowrap;">Continue with Google</span>
      </button>
      </br>
      <!-- Lightweight states + dark mode -->
      <style>
        #googleLoginButton:hover { background:#f9fafb; box-shadow:0 2px 6px rgba(0,0,0,0.06); }
        #googleLoginButton:active { transform:translateY(0.5px); }
        #googleLoginButton:focus { outline:2px solid #2563eb33; outline-offset:2px; }

        @media (prefers-color-scheme: dark) {
          #oauthDivider { background:#26272b; }
          #googleLoginButton {
            background:#0b0b0c; border-color:#26272b; color:#e5e7eb;
            box-shadow:0 1px 2px rgba(0,0,0,0.6);
          }
          #googleLoginButton:hover { background:#131316; box-shadow:0 2px 6px rgba(0,0,0,0.7); }
          #googleLoginButton:focus { outline:2px solid #60a5fa33; }
        }
      </style>
      </div>
    </form>
  </div>
</div>

<div id="disclaimerPopup" class="popup">
  <p>Deep Think Mode!</p>
</div>
<div id="popupContainer">
  <!-- Modal zum Editieren des Systemprompts -->
  <div id="systemPromptModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span id="closeSystemPromptModal" class="close">&times;</span>
      <h2>Edit System Prompt</h2>
      <p>When empty, default is applied.</p>
      <textarea id="systemPromptInput" class="systemPromptInputSytle" rows="4" style="width:98%;"></textarea>
      <button id="saveSystemPromptBtn">Save</button>
    </div>
  </div>
</div>

<!-- Hilfebutton (z.B. in der unteren rechten Ecke) -->
<button id="helpButton" class="help-button" title="Hilfe & Erklärung">
  &#63;
</button>

<!-- FAQ Modal -->
<div id="helpModal" class="modal">
  <div class="modal-content faq-modal">
    <span class="close" id="closeHelpModal">&times;</span>
    <div class="faq-header">
      <h2>FAQ & Quick Start</h2>
    </div>
    <div class="faq-body">
      <div class="faq-intro">
        <p>
          <strong>What is consens.io?</strong><br>
          consens.io runs your query in parallel across multiple large language models and presents their answers side by side. In addition, it can integrate external search systems to retrieve current and verifiable information.
        </p>
        <p><strong>Benefits:</strong><br>
          ✓ Systematic comparison of Models<br>
          ✓ Structured consensus building<br>
          ✓ Integration of web-based research sources<br>
        </p>
      </div>

      <div class="faq-item">
        <h3>
          <span class="faq-number">1.</span>
          What is Auto Consensus?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Auto Consensus automatically analyses several model responses, identifies agreements and discrepancies, and generates a consolidated answer. The goal is a transparent and robust synthesis of the available outputs.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">2.</span>
          What does Consensus Button do?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          The Consensus Button combines the selected model responses into a single joint answer. Before running it, you can include or exclude individual responses so that only the models you consider relevant contribute to the final result.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">3.</span>
          What is the Consensus Model?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          The Consensus Model is a dedicated model that does not answer user queries directly. Instead, it evaluates, structures, and synthesises the already generated model responses into a coherent overall statement.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">4.</span>
          What does “Differences” show?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Differences highlights substantive deviations between the model responses. This makes it easier to see where models arrive at different conclusions or add distinct perspectives.
        </p>
      </div>

      <div class="faq-item">
        <h3>
          <span class="faq-number">5.</span>
          What is Deep Think Mode?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Deep Think Mode produces a detailed, step-by-step reasoning trace for selected models. It is intended for complex or explanation-heavy tasks where the reasoning process is as important as the final answer.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">6.</span>
          What does Web Search include?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Web Search forwards your query to a grounding Model in the background. The crawled webpages are passed to all the models. The results are displayed directly within consens.io.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">7.</span>
          What is the purpose of including or excluding answers?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          By including or excluding individual model answers, you control which outputs are used in the consensus generation. This allows you to filter out low-quality or irrelevant responses before they influence the final result.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">8.</span>
          When do I need to enter API keys?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          API keys are only required if you want to use your own model access or if you are not logged in and still wish to query certain providers through your personal credentials.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">9.</span>
          Which AI models are available?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          consens.io provides access to current large language models from several providers, including OpenAI, Mistral, Anthropic, Grok, DeepSeek and Google Gemini.
        </p>
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">10.</span>
          How do Bookmarks and Leaderboards work?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Logged-in users can bookmark specific queries and revisit them later. Leaderboards present frequently used or particularly interesting queries by other users, enabling comparison of prompts and outcomes.
        </p>
      </div>

      <div class="faq-item">
        <h3>
          <span class="faq-number">11.</span>
          How many queries can I make?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          Users without their own subscription or external keys can run up to 25 standard AI-powered queries and an additional 12 queries in Deep Think Mode. The remaining quota is displayed in the sidebar.
        </p>        
      </div>
      
      <div class="faq-item">
        <h3>
          <span class="faq-number">12.</span>
          Why is there a free quota?
          <span class="faq-toggle-icon">＋</span>
        </h3>
        <p>
          The free quota is intended to allow an initial, non-committal exploration of consens.io. It enables you to test model comparison, consensus building, and web search features before deciding whether you want to use your own API keys or extended access.
        </p>        
      </div>      
    </div>
  </div>
</div>

<div class="feedback-line">
  <span class="feedback-note">
    Please avoid personal or sensitive data. AI models can make mistakes.
  </span>
  <button id="feedbackButton" class="feedback-button" title="Feedback senden">Feedback</button>
  <a href="/privacy"  target="_blank" rel="noopener noreferrer" class="privacy-inline-link" title="Privacy Policy" aria-label="Privacy Policy">Privacy</a>
  <a href="/imprint"  target="_blank" rel="noopener noreferrer" class="privacy-inline-link" title="Imprint"        aria-label="Imprint">Imprint</a>
  <a href="/about"  target="_blank" rel="noopener noreferrer" class="privacy-inline-link" title="About"        aria-label="About">About</a>
  <span id="feedback-note"></span>
</div>

<!-- Feedback Modal -->
<div id="feedbackModal" class="modal">
  <div class="modal-content feedback-modal">
    <span class="close" id="closeFeedbackModal">&times;</span>
    <h2>Send Feedback</h2>
    <form id="feedbackForm">
      <textarea name="message" placeholder="Your Feedback"></textarea>
      <input type="email" name="email" placeholder="Your email (optional)">
      <button type="submit">Submit</button>
    </form>
  </div>
</div>

<script>
  (function () {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) 
                  || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1); // iPadOS
    if (isIOS) document.documentElement.classList.add('ios');
  })();

  function colorizeCredibility(md) {
    if (!md) return md;
    const lines = md.trim().split("\n");
    if (!lines.length) return md;

    const first = lines[0].toLowerCase();
    const mapping = [
      { key: " very ",     cls: "cred-very" },
      { key: " largely ",  cls: "cred-largely" },
      { key: " partially ",cls: "cred-partially" },
      { key: " hardly ",   cls: "cred-hardly" },
      { key: " not ",      cls: "cred-not" }
    ];

    // Robust: prüft auf vollständige Satzfragmente
    let cls = null;
    if (first.includes("the consensus answer is")) {
      for (const m of mapping) {
        if (first.includes(m.key.trim())) { cls = m.cls; break; }
      }
    }

    if (cls) {
      // Markdown-Bold **…** in der Badge vermeiden, damit die Farbe klar lesbar bleibt
      const clean = lines[0].replace(/\*\*/g, "");
      lines[0] = `<span class="cred-badge ${cls}">${clean}</span>`;
      return lines.join("\n");
    }
    return md;
  }

</script>

</body>
</html>