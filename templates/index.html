<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>consens.io</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <link rel="icon" href="/static/favicon.png" type="image/x-icon">
  <!-- Füge dies im <head> hinzu -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Optional für Sicherheit: -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <script>
    window.FIREBASE_CONFIG = {
      apiKey: "{{ firebase_api_key }}",
      authDomain: "{{ firebase_auth_domain }}",
      projectId: "{{ firebase_project_id }}",
      storageBucket: "{{ firebase_storage_bucket }}",
      messagingSenderId: "{{ firebase_messaging_sender_id }}",
      appId: "{{ firebase_app_id }}"
    };
  </script>
</head>
<body>
<!-- Marketing Popup -->
<div id="marketingPopup" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Willkommen bei <span class="highlight">consens.io</span></h2>
    <p class="subheading"><span style="background-color: rgba(255,215,0,0.4); padding: 0 5px;">KI macht Fehler. Wir machen sie sichtbar.</p>

    <div class="benefits">
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Modellvergleich:</strong>
        <span>Erhalte Antworten von verschiedenen KI-Modellen parallel.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Transparenz:</strong>
        <span>Erkenne Unterschiede und Gemeinsamkeiten auf einen Blick.</span>
      </div>
      <br/>
      <div class="benefit">
        <span class="benefit-icon">✔</span>
        <strong>Flexibel nutzbar:</strong>
        <span>Eigene API-Keys hinterlegen oder direkt kostenlos testen.</span>
      </div>
    </div>

    <p class="cta-text">Log dich ein, um kostenlos und unverbindlich zu starten.</p>

    <button id="startNowButton" class="cta-button">Loslegen</button>
  </div>
</div>
  <header class="top-bar">
    <!-- Sidebar Toggle Button -->
    <button id="toggleSidebarButton" class="sidebar-toggle collapse-btn">
      <span class="burger-icon">&#9776;</span>
    </button>
    <!-- Logo und Titel -->
    <div class="top-bar-logo">
      <img src="/static/favicon.png" alt="Favicon" class="top-bar-favicon">
      <span class="top-bar-title">consens.io</span>
    </div>
    <!-- Container für rechte Elemente -->
    <div class="top-bar-right">
      <div id="loginContainer" class="login-text">Einloggen und gratis nutzen</div>
      <div class="mode-switch">
        <label class="switch">
          <input type="checkbox" id="modeToggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </header>
   
  <br/><br/><br/>
<!-- Sidebar für API Keys -->
<div class="sidebar">
  <div class="sidebar-content">
    <div class="sidebar-header">
      <div class="sidebar-tooltip">
        <h2>API Keys</h2>
        <div class="sidebar-tooltiptext">Eigene API-Keys hinterlegen – nötig nur ohne Login oder bei erschöpftem Kontingent.</div>
      </div>      
      <button id="toggleApiTest" onclick="toggleApiTest()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="apiTestArea" class="api-test-area">
      <div class="api-key-group">
        <label for="openaiKey">OpenAI API Key <span id="openaiFeedback" class="feedback"></span></label>
        <input type="password" id="openaiKey" placeholder="Dein OpenAI Key">
      </div>
      <div class="api-key-group">
        <label for="mistralKey">Mistral API Key <span id="mistralFeedback" class="feedback"></span></label>
        <input type="password" id="mistralKey" placeholder="Dein Mistral Key">
      </div>
      <div class="api-key-group">
        <label for="anthropicKey">Anthropic API Key <span id="anthropicFeedback" class="feedback"></span></label>
        <input type="password" id="anthropicKey" placeholder="Dein Anthropic Key">
      </div>
      <div class="api-key-group">
        <label for="geminiKey">Google API Key <span id="geminiFeedback" class="feedback"></span></label>
        <input type="password" id="geminiKey" placeholder="Dein Gemini Key">
      </div>
      <div class="api-key-group">
        <label for="deepseekKey">DeepSeek API Key <span id="deepseekFeedback" class="feedback"></span></label>
        <input type="password" id="deepseekKey" placeholder="Dein DeepSeek Key">
      </div>
      <div class="api-key-group">
        <label for="grokKey">Grok API Key <span id="grokFeedback" class="feedback"></span></label>
        <input type="password" id="grokKey" placeholder="Dein Grok Key">
      </div>      
      <div class="sidebar-tooltip">
        <button onclick="testAllKeys()">
          Alle APIs testen 
          <span id="apiSpinner" class="spinner" style="display: none;"></span>
        </button>
        <div class="sidebar-tooltiptext">Dauert circa 1 min.</div>
      </div>      
    </div>
    <div id="usageOptions">
      <label for="useOwnKeysSwitch" class="custom-checkbox-label">
        Eigene API Keys verwenden
        <input type="checkbox" id="useOwnKeysSwitch">
      </label>
      <span id="freeUsageDisplay">Gratis-Anfragen: ...</span>
    </div>       

    <!-- Trennstrich zwischen API Keys und Modelle -->
    <div class="sidebar-separator"></div>

    <!-- Verwendete Modelle (einklappbar) -->
    <div class="sidebar-header">
      <h2>Verwendete Modelle</h2>
      <button id="toggleModelSelection" onclick="toggleModelSelection()" class="collapse-btn">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="modelSelectionArea" class="model-selection">
      <label for="selectOpenAI">
        <input type="checkbox" id="selectOpenAI" checked> OpenAI
      </label>
      <label for="selectMistral">
        <input type="checkbox" id="selectMistral" checked> Mistral
      </label>
      <label for="selectClaude">
        <input type="checkbox" id="selectClaude" checked> Anthropic Claude
      </label>
      <label for="selectGemini">
        <input type="checkbox" id="selectGemini" checked> Google Gemini
      </label>
      <label for="selectDeepSeek">
        <input type="checkbox" id="selectDeepSeek" checked> DeepSeek
      </label>
      <label for="selectGrok">
        <input type="checkbox" id="selectGrok" checked> Grok
      </label>      
    </div>

    <!-- Trennstrich zwischen API Keys und Leaderboard -->
    <div class="sidebar-separator"></div>

    <!-- Leaderboard -->
    <div class="sidebar-header">
      <h2>Leaderboard</h2>
      <button id="toggleLeaderboard" class="collapse-btn" onclick="toggleLeaderboard()">
        <span class="arrow">&#9660;</span>
      </button>
    </div>
    <div id="leaderboardContentContainer" class="hidden">
      <div id="leaderboardContent"></div>
    </div>
  </div>
</div>

  <!-- Mode-Switch in der oberen rechten Ecke -->
  <div class="mode-switch">
    <label class="switch">
      <input type="checkbox" id="modeToggle">
      <span class="slider"></span>
    </label>
  </div>

  <div class="container">
    <div class="input-section">
      <div class="chat-input-container" style="position: relative;">
        <textarea class="input-field" id="questionInput" placeholder="Geben Sie Ihre Frage ein"></textarea>
        <button id="toggleAllButton" onclick="toggleAllResponses()" title="Alle Antworten ein- oder ausklappen">
          <span class="toggle-visual"></span>
        </button>
        <!-- Container für beide Schalter -->
        <div class="consensus-switch-container" style="position: absolute; bottom: 10px; left: 10px; display: flex; align-items: center; gap: 20px;">
          <!-- Auto-Konsens-Switch -->
          <div class="auto-consensus">
            <label class="switch">
              <input type="checkbox" id="autoConsensusToggle">
              <span class="slider"></span>
            </label>
            <span class="auto-consensus-label">Auto Konsens</span>
          </div>
          <!-- Search Mode Switch, standardmäßig leicht ausgegraut -->
          <div class="search-mode">
            <label class="switch">
              <input type="checkbox" id="searchModeToggle">
              <span class="slider"></span>
            </label>
            <span class="search-mode-label">Search Mode</span>
            <!-- Disclaimer, der nur beim Aktivieren angezeigt wird -->
            <span id="searchDisclaimer" class="search-disclaimer" style="display: none; font-size: 0.8em; margin-left: 5px;">
              Aktuell nur mit ChatGPT und Gemini, bald auch mit weiteren Modellen nutzbar!
            </span>
          </div>
        </div>
        <button class="button" id="sendButton" onclick="sendQuestion()">
          <!-- SVG-Icon für einen Pfeil, der nach unten zeigt -->
          <svg class="input-icon" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="response-section" style="position: relative;">
      <!-- Antwort OpenAI -->
      <div class="response-box" id="openaiResponse" data-model="OpenAI">
        <h2>
          <span class="title">Antwort von ChatGPT <small>(GPT-4o)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('openaiResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('openaiResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('openaiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Mistral -->
      <div class="response-box" id="mistralResponse" data-model="Mistral">
        <h2>
          <span class="title">Antwort von Mistral <small>(mistral-large-latest)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('mistralResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('mistralResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('mistralResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Anthropic Claude -->
      <div class="response-box" id="claudeResponse" data-model="Anthropic Claude">
        <h2>
          <span class="title">Antwort von Claude <small>(claude-3-5-sonnet)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('claudeResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('claudeResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('claudeResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Google Gemini -->
      <div class="response-box" id="geminiResponse" data-model="Gemini">
        <h2>
          <span class="title">Antwort von Gemini <small>(gemini-pro)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('geminiResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('geminiResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('geminiResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort DeepSeek -->
      <div class="response-box" id="deepseekResponse" data-model="DeepSeek">
        <h2>
          <span class="title">Antwort von DeepSeek <small>(deepseek-chat)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('deepseekResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('deepseekResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('deepseekResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>
      <!-- Antwort Grok -->
      <div class="response-box" id="grokResponse" data-model="Grok">
        <h2>
          <span class="title">Antwort von Grok <small>(grok-model)</small></span>
          <div class="control-icons">
            <span class="best-btn" onclick="toggleBest('grokResponse')" title="Als beste Antwort markieren">&#10003;</span>
            <span class="exclude-btn" onclick="toggleExclude('grokResponse')" title="Antwort ausschließen">&#10005;</span>
            <button class="collapse-btn" onclick="toggleCollapse('grokResponse')">
              <span class="arrow">&#9660;</span>
            </button>
          </div>
        </h2>
        <p class="collapsible-content"></p>
      </div>     
    </div>
    
    <!-- Konsens-Section -->
    <div class="consensus-section">
      <div class="consensus-wrapper">
        <!-- Konsens-Kontrolle: Schalter, Button und Dropdown wie gehabt -->
        <div class="consensus-controls">
          <!-- Tooltip-Wrapper um den Button -->
          <div class="tooltip">
            <button id="consensusButton" onclick="getConsensus()">Konsens‑Antwort generieren</button>
            <!-- Das Hover-Feld mit weiteren Infos -->
            <div class="tooltiptext">
              Bündele vier Antworten zu einem finalen, konsistenten Konsens, indem du Widersprüche und Fehler abgleichst.
            </div>
          </div>
          <div class="consensus-model">
            <label for="consensusModelDropdown" class="consensus-label">Konsens‑Modell:</label>
            <div class="select-wrapper">
              <select id="consensusModelDropdown">
                <option value="Anthropic Claude">claude-3-5</option>
                <option value="Mistral">mistral-large-latest</option>
                <option value="OpenAI">GPT‑4o</option>
                <option value="Google Gemini">gemini-pro</option>
                <option value="DeepSeek">deepseek-chat</option>
                <option value="Grok">grok-chat</option>
              </select>
            </div>
          </div>
        </div>
        <!-- Konsens-Box mit zwei nebeneinanderliegenden Bereichen -->
        <div class="consensus-box" id="consensusResponse">
          <!-- Linker Bereich: Konsens-Antwort (80%) -->
          <div class="consensus-main">
            <h2>Konsens‑Antwort</h2>
            <p></p>
          </div>
          <!-- Rechter Bereich: Unterschiede (20%) -->
          <div class="consensus-differences">
            <h2>Unterschiede</h2>
            <p></p>
          </div>
        </div>
      </div>
    </div>

  <script>
    document.addEventListener("DOMContentLoaded", function() {
      // --------------------------
      // Dark/Light Mode Initialisierung
      // --------------------------
      const modeToggle = document.getElementById("modeToggle");
      const darkModeStored = localStorage.getItem("darkMode");
      if (darkModeStored === "true") {
        document.body.classList.add("dark-mode");
        modeToggle.checked = true;
      } else {
        document.body.classList.remove("dark-mode");
        modeToggle.checked = false;
      }
      modeToggle.addEventListener("change", function() {
        const isDark = this.checked;
        document.body.classList.toggle("dark-mode", isDark);
        localStorage.setItem("darkMode", isDark ? "true" : "false");
      });
      
      // --------------------------
      // Marketing Popup Initialisierung
      // --------------------------
      // Überprüfen, ob das Popup schon angezeigt wurde

      const FREE_USAGE_LIMIT = 25;

      if (!localStorage.getItem("marketingPopupShown")) {
        document.getElementById("marketingPopup").style.display = "block";
        document.body.classList.add("modal-open");
      }

      // Popup schließen, wenn auf das "x" geklickt wird
      document.querySelector("#marketingPopup .close").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        document.body.classList.remove("modal-open");
        localStorage.setItem("marketingPopupShown", "true");
      });

      // Popup schließen, wenn der "Jetzt starten"-Button geklickt wird
      document.getElementById("startNowButton").addEventListener("click", function() {
        document.getElementById("marketingPopup").style.display = "none";
        localStorage.setItem("marketingPopupShown", "true");
      });

      document.addEventListener("click", function(event) {
        const sidebar = document.querySelector('.sidebar');
        const burgerButton = document.querySelector('.sidebar-toggle');
        
        // Nur auf kleinen Displays
        if (window.innerWidth <= 1400 && sidebar.classList.contains("active")) {
          // Wenn der Klick weder innerhalb der Sidebar noch auf dem Burger-Button erfolgt
          if (!sidebar.contains(event.target) && !event.target.closest('.sidebar-toggle')) {
            sidebar.classList.remove("active");
          }
        }
      });

      const freeDisplay = document.getElementById("freeUsageDisplay");
      const idToken = localStorage.getItem("id_token");
      if (idToken && freeDisplay) {
        fetch("/usage", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ id_token: idToken })
        })
          .then(response => response.json())
          .then(data => {
            freeDisplay.innerText = "Gratis-Anfragen: " + data.remaining + " / " + 25;
          })
          .catch(err => console.error("Fehler beim Abrufen des Kontingents:", err));
      }

      // --------------------------
      // Event-Listener für Eingabefelder und Buttons
      // --------------------------
    
      // Frage per Enter (ohne Zeilenumbruch) absenden
      document.getElementById("questionInput").addEventListener("keydown", function(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          sendQuestion();
        }
      });
    
      document.getElementById("toggleSidebarButton").addEventListener("click", function() {
        const sidebar = document.querySelector(".sidebar");
        sidebar.classList.toggle("collapsed");
      });

      document.getElementById('toggleSidebarButton').addEventListener('click', function() {
        const sidebar = document.querySelector('.sidebar');
        sidebar.classList.toggle('active');
      });
    
      // Fenstergröße prüfen – wenn <1024px, Sidebar einklappen
      function checkWindowSize() {
        const sidebar = document.querySelector(".sidebar");
        if (window.innerWidth < 1024) {
          sidebar.classList.add("collapsed");
        } else {
          sidebar.classList.remove("collapsed");
        }
        updateToggleButton();
      }
      window.addEventListener("resize", checkWindowSize);
      checkWindowSize(); // Initial
    
      // Aktualisiert den Pfeil des Sidebar-Toggle-Buttons
      function updateToggleButton() {
        const sidebar = document.querySelector(".sidebar");
        const newText = sidebar.classList.contains("collapsed") ? "►" : "◄";
        const arrow = document.querySelector(".sidebar-toggle .arrow");
        if (arrow) {
          arrow.textContent = newText;
        }
      }

      // Extrahiert aus dem Differences-Text den BestModel-Wert
      function parseBestModel(differencesText) {
        const regex = /BestModel:\s*(.*)/i;
        const match = differencesText.match(regex);
        return match ? match[1].trim() : null;
      }
    
      // --------------------------
      // Globale Funktionen (für Inline-Aufrufe)
      // --------------------------

      window.toggleBest = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("excluded")) return;
        if (box.classList.contains("best")) {
          box.classList.remove("best");
        } else {
          document.querySelectorAll(".response-box").forEach(b => b.classList.remove("best"));
          box.classList.add("best");
          const model = box.getAttribute("data-model");
          // Direkter Aufruf zur Firebase-Funktion:
          recordModelVote(model, "best");
        }
      };

      // API Testbereich umschalten (für den Pfeil in der API Keys Section)
      window.toggleApiTest = function() {
        const area = document.getElementById("apiTestArea");
        const button = document.getElementById("toggleApiTest");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };
    
      // Modelle-Auswahl umschalten (für den Pfeil in der Modelle Section)
      window.toggleModelSelection = function() {
        const area = document.getElementById("modelSelectionArea");
        const button = document.getElementById("toggleModelSelection");
        const arrow = button.querySelector(".arrow");
        if (area.style.display === "none" || area.style.display === "") {
          area.style.display = "block";
          arrow.classList.add("rotated");
        } else {
          area.style.display = "none";
          arrow.classList.remove("rotated");
        }
      };

      window.toggleAllResponses = function() {
        const responses = document.querySelectorAll('.response-box');
        let shouldCollapse = false;
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          if (content && !content.classList.contains('collapsed')) {
            shouldCollapse = true;
          }
        });
        
        responses.forEach(box => {
          const content = box.querySelector('.collapsible-content');
          const arrow = box.querySelector('.collapse-btn .arrow');
          if (shouldCollapse) {
            if (content && !content.classList.contains('collapsed')) {
              content.classList.add('collapsed');
            }
            if (arrow && !arrow.classList.contains('rotated')) {
              arrow.classList.add('rotated');
            }
          } else {
            if (content && content.classList.contains('collapsed')) {
              content.classList.remove('collapsed');
            }
            if (arrow && arrow.classList.contains('rotated')) {
              arrow.classList.remove('rotated');
            }
          }
        });
      };
    
      // Collapse/Expand einer Antwort-Box
      window.toggleCollapse = function(responseId) {
        const responseBox = document.getElementById(responseId);
        const content = responseBox.querySelector(".collapsible-content");
        const arrow = responseBox.querySelector(".collapse-btn .arrow");
        content.classList.toggle("collapsed");
        arrow.classList.toggle("rotated");
      };
    
      // Exclude/Include einer Antwort-Box (falls nicht als "best" markiert)
      window.toggleExclude = function(responseId) {
        const box = document.getElementById(responseId);
        if (box.classList.contains("best")) return;
        box.classList.toggle("excluded");
      };
    
      let leaderboardInterval; // Variable zum Speichern des Interval-IDs

      window.toggleLeaderboard = function() {
        const container = document.getElementById("leaderboardContentContainer");
        const arrow = document.getElementById("toggleLeaderboard").querySelector(".arrow");
        container.classList.toggle("hidden");
        arrow.classList.toggle("rotated");
      };

      // Globale Variable
      let consensusGenerated = false;

      // Senden der Frage an die aktiven Modelle
      window.sendQuestion = async function() {
        const question = document.getElementById("questionInput").value;
        consensusGenerated = false;
        if (!question) {
          alert("Bitte geben Sie eine Frage ein.");
          return;
        }
        const spinnerHTML = '<span class="spinner"></span>';
        let activeModels = [];
        if (document.getElementById("selectOpenAI").checked) activeModels.push("OpenAI");
        if (document.getElementById("selectMistral").checked) activeModels.push("Mistral");
        if (document.getElementById("selectClaude").checked) activeModels.push("Anthropic Claude");
        if (document.getElementById("selectGemini").checked) activeModels.push("Google Gemini");
        if (document.getElementById("selectDeepSeek").checked) activeModels.push("DeepSeek");
        if (document.getElementById("selectGrok").checked) activeModels.push("Grok");
    
        // Spinner in den jeweiligen Response-Boxen setzen
        if (activeModels.includes("OpenAI")) {
          document.getElementById("openaiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Mistral")) {
          document.getElementById("mistralResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Anthropic Claude")) {
          document.getElementById("claudeResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Google Gemini")) {
          document.getElementById("geminiResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("DeepSeek")) {
          document.getElementById("deepseekResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (activeModels.includes("Grok")) {
          document.getElementById("grokResponse").querySelector(".collapsible-content").innerHTML = spinnerHTML;
        }
        if (document.getElementById("autoConsensusToggle").checked) {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = spinnerHTML;
        } else {
          document.getElementById("consensusResponse").querySelector("p").innerHTML = "";
        }
    
        // API Keys aus localStorage abrufen
        const openaiKey = localStorage.getItem("openaiKey") || "";
        const mistralKey = localStorage.getItem("mistralKey") || "";
        const anthropicKey = localStorage.getItem("anthropicKey") || "";
        const geminiKey = localStorage.getItem("geminiKey") || "";
        const deepseekKey = localStorage.getItem("deepseekKey") || "";
        const grokKey = localStorage.getItem("grokKey") || "";
    
        let responsesReceived = 0;
        const totalActive = activeModels.length;
        function checkAllResponses() {
          responsesReceived++;
          if (responsesReceived === totalActive && document.getElementById("autoConsensusToggle").checked) {
            getConsensus();
          }
        }

      // Hilfsfunktion, um einen leeren API Key zu prüfen
      function validateUserKey(keyName) {
        const key = localStorage.getItem(keyName);
        return key && key.trim() !== "";
      }

      // OpenAI
      if (activeModels.includes("OpenAI")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1,  // Passe diesen Wert ggf. dynamisch an
          // Hier wird der neue Parameter hinzugefügt:
          search_mode: document.getElementById("searchModeToggle").checked
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("openaiKey") || "";
          }
        } else {
          if (!validateUserKey("openaiKey")) {
            alert("Bitte geben Sie einen gültigen OpenAI API Key ein.");
            return;
          }
          payload.api_key = localStorage.getItem("openaiKey");
        }

        fetch('/ask_openai', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("openaiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei OpenAI:", error);
            checkAllResponses();
          });
      }


      // Mistral
      if (activeModels.includes("Mistral")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("mistralKey") || "";
          }
        } else {
          if (!validateUserKey("mistralKey")) {
            alert("Bitte geben Sie einen gültigen Mistral API Key ein.");
            return;
          }
          payload.api_key = localStorage.getItem("mistralKey");
        }

        fetch('/ask_mistral', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("mistralResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei Mistral:", error);
            checkAllResponses();
          });
      }

      // Anthropic Claude
      if (activeModels.includes("Anthropic Claude")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("anthropicKey") || "";
          }
        } else {
          if (!validateUserKey("anthropicKey")) {
            alert("Bitte geben Sie einen gültigen Anthropic API Key ein.");
            return;
          }
          payload.api_key = localStorage.getItem("anthropicKey");
        }

        fetch('/ask_claude', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("claudeResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei Anthropic Claude:", error);
            checkAllResponses();
          });
      }

      // Google Gemini
      if (activeModels.includes("Google Gemini")) {
          const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
          const payload = {
            question: question,
            active_count: 1,
            // Suche-Parameter hinzufügen:
            search_mode: document.getElementById("searchModeToggle").checked
          };

          if (!useOwnKeys) {
            let id_token = localStorage.getItem("id_token");
            if (id_token) {
              payload.id_token = id_token;
            } else {
              payload.api_key = localStorage.getItem("geminiKey") || "";
            }
          } else {
            if (!validateUserKey("geminiKey")) {
              alert("Bitte geben Sie einen gültigen Google Gemini API Key ein.");
              return;
            }
            payload.api_key = localStorage.getItem("geminiKey");
          }

          fetch('/ask_gemini', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("geminiResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei Google Gemini:", error);
            checkAllResponses();
          });
      }

      // DeepSeek
      if (activeModels.includes("DeepSeek")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1
        };

        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("deepseekKey") || "";
          }
        } else {
          if (!validateUserKey("deepseekKey")) {
            alert("Bitte geben Sie einen gültigen DeepSeek API Key ein.");
            return;
          }
          payload.api_key = localStorage.getItem("deepseekKey");
        }

        fetch('/ask_deepseek', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            const outputEl = document.getElementById("deepseekResponse").querySelector(".collapsible-content");
            if (data.response) {
              outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
            } else if (data.error) {
              outputEl.innerText = data.error;
            } else {
              outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
            }
            if (data.free_usage_remaining !== undefined) {
              document.getElementById("freeUsageDisplay").innerText =
                "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
            }
            checkAllResponses();
          })
          .catch(error => {
            console.error("Fehler bei DeepSeek:", error);
            checkAllResponses();
          });
      }

      // Grok
      if (activeModels.includes("Grok")) {
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        const payload = {
          question: question,
          active_count: 1
        };
        if (!useOwnKeys) {
          let id_token = localStorage.getItem("id_token");
          if (id_token) {
            payload.id_token = id_token;
          } else {
            payload.api_key = localStorage.getItem("grokKey") || "";
          }
        } else {
          if (!validateUserKey("grokKey")) {
            alert("Bitte geben Sie einen gültigen Grok API Key ein.");
            return;
          }
          payload.api_key = localStorage.getItem("grokKey");
        }
        fetch('/ask_grok', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
          const outputEl = document.getElementById("grokResponse").querySelector(".collapsible-content");
          if (data.response) {
            outputEl.innerHTML = DOMPurify.sanitize(marked.parse(data.response));
          } else if (data.error) {
            outputEl.innerText = data.error;
          } else {
            outputEl.innerText = "Bitte loggen Sie sich ein oder hinterlegen Sie eigene API Keys.";
          }
          if (data.free_usage_remaining !== undefined) {
            document.getElementById("freeUsageDisplay").innerText =
              "Gratis-Anfragen: " + data.free_usage_remaining + " / " + FREE_USAGE_LIMIT;
          }
          checkAllResponses();
        })
        .catch(error => {
          console.error("Fehler bei Grok:", error);
          checkAllResponses();
        });
    }
    };
    
      // Modelle (Checkboxen) ein-/ausschalten
      window.toggleModel = function(responseId, isChecked) {
        const box = document.getElementById(responseId);
        if (!isChecked) {
          box.classList.add("excluded");
        } else {
          box.classList.remove("excluded");
        }
      };
      document.getElementById("selectOpenAI").addEventListener("change", function() {
        toggleModel("openaiResponse", this.checked);
      });
      document.getElementById("selectMistral").addEventListener("change", function() {
        toggleModel("mistralResponse", this.checked);
      });
      document.getElementById("selectClaude").addEventListener("change", function() {
        toggleModel("claudeResponse", this.checked);
      });
      document.getElementById("selectGemini").addEventListener("change", function() {
        toggleModel("geminiResponse", this.checked);
      });
      document.getElementById("selectDeepSeek").addEventListener("change", function() {
        toggleModel("deepseekResponse", this.checked);
      });
      document.getElementById("selectGrok").addEventListener("change", function() {
        toggleModel("grokResponse", this.checked);
      });
    
      // Erneut API Keys in Felder schreiben (falls benötigt)
      ["openaiKey", "mistralKey", "anthropicKey", "geminiKey", "deepseekKey", "grokKey"].forEach(function(key) {
        const stored = localStorage.getItem(key);
        if (stored) {
          document.getElementById(key).value = stored;
        }
      });

    // Search Mode Toggle: Modelle automatisch anpassen, wenn aktiviert
    const searchModeToggle = document.getElementById("searchModeToggle");
    const searchDisclaimer = document.getElementById("searchDisclaimer");

    function showDisclaimerPopup() {
      const popup = document.getElementById('disclaimerPopup');
      popup.classList.add('show');
      // Popup nach 3 Sekunden wieder ausblenden
      setTimeout(() => {
        popup.classList.remove('show');
      }, 5000);
    }

    searchModeToggle.addEventListener("change", function() {
      const isSearchMode = this.checked;

      // Hole die Checkboxen der Modelle
      const openaiCheckbox = document.getElementById("selectOpenAI");
      const mistralCheckbox = document.getElementById("selectMistral");
      const claudeCheckbox = document.getElementById("selectClaude");
      const geminiCheckbox = document.getElementById("selectGemini");
      const deepseekCheckbox = document.getElementById("selectDeepSeek");
      const grokCheckbox = document.getElementById("selectGrok");

      // Hole das Konsens-Dropdown
      const consensusDropdown = document.getElementById("consensusModelDropdown");

      if (isSearchMode) {
        // Zeige den Inline-Disclaimer zunächst an
        searchDisclaimer.style.display = "inline-block";
        
        // Nur OpenAI (ChatGPT) unterstützt aktuell den Search Mode.
        // Deaktiviere und deaktiviere alle anderen Modelle.
        mistralCheckbox.checked = false;
        claudeCheckbox.checked = false;
        deepseekCheckbox.checked = false;
        grokCheckbox.checked = false;

        mistralCheckbox.disabled = true;
        claudeCheckbox.disabled = true;
        deepseekCheckbox.disabled = true;
        grokCheckbox.disabled = true;

        // Optional: Setze die zugehörigen Response-Boxen auf "ausgeschlossen"
        toggleModel("mistralResponse", false);
        toggleModel("claudeResponse", false);
        toggleModel("deepseekResponse", false);
        toggleModel("grokResponse", false);

        // Setze das Konsensmodell automatisch auf OpenAI und deaktiviere die Auswahl
        consensusDropdown.value = "OpenAI";
        consensusDropdown.disabled = true;

        // Auf kleinen Bildschirmen: Popup anzeigen statt Inline-Disclaimer
        if (window.innerWidth < 768) {
          showDisclaimerPopup();
          searchDisclaimer.style.display = "none";
        }
      } else {
        // Schalte den Inline-Disclaimer aus
        searchDisclaimer.style.display = "none";

        // Reaktiviere alle Modelle, wenn der Search Mode ausgeschaltet wird.
        mistralCheckbox.disabled = false;
        claudeCheckbox.disabled = false;
        deepseekCheckbox.disabled = false;
        grokCheckbox.disabled = false;

        // Setze die Checkboxen wieder auf "angewählt"
        mistralCheckbox.checked = true;
        claudeCheckbox.checked = true;
        deepseekCheckbox.checked = true;
        grokCheckbox.checked = true;

        // Aktualisiere die zugehörigen Response-Boxen als "nicht ausgeschlossen"
        toggleModel("mistralResponse", true);
        toggleModel("claudeResponse", true);
        toggleModel("geminiResponse", true);
        toggleModel("deepseekResponse", true);
        toggleModel("grokResponse", true);

        // Reaktiviere das Konsens-Dropdown
        consensusDropdown.disabled = false;
      }
    });
    
      // Globale Variable, um die letzte verarbeitete Frage zu speichern.
      let lastQuestion = "";

      window.getConsensus = async function() {
        const question = document.getElementById("questionInput").value.trim();
          // Status, ob eigene API Keys genutzt werden sollen
        const useOwnKeys = document.getElementById("useOwnKeysSwitch").checked;
        
        // Nur im Gratis-Modus id_token abrufen
        const id_token = useOwnKeys ? null : localStorage.getItem("id_token");

        // Wenn die Frage neu oder geändert ist, werden Firebase-Votes aktualisiert.
        if (question !== lastQuestion) {
          // Für jedes Modell prüfen, ob es als "best" markiert ist.
          if (document.getElementById("openaiResponse").classList.contains("best")) {
            recordModelVote("OpenAI", "best");
          }
          if (document.getElementById("mistralResponse").classList.contains("best")) {
            recordModelVote("Mistral", "best");
          }
          if (document.getElementById("claudeResponse").classList.contains("best")) {
            recordModelVote("Anthropic", "best");
          }
          if (document.getElementById("geminiResponse").classList.contains("best")) {
            recordModelVote("Gemini", "best");
          }
          if (document.getElementById("deepseekResponse").classList.contains("best")) {
            recordModelVote("DeepSeek", "best");
          }
          if (document.getElementById("grokResponse").classList.contains("best")) {
            recordModelVote("Grok", "best");
          }

          // Ebenso für "excluded" (sofern du das separat erfassen möchtest).
          if (document.getElementById("openaiResponse").classList.contains("excluded")) {
            recordModelVote("OpenAI", "exclude");
          }
          if (document.getElementById("mistralResponse").classList.contains("excluded")) {
            recordModelVote("Mistral", "exclude");
          }
          if (document.getElementById("claudeResponse").classList.contains("excluded")) {
            recordModelVote("Anthropic", "exclude");
          }
          if (document.getElementById("geminiResponse").classList.contains("excluded")) {
            recordModelVote("Gemini", "exclude");
          }
          if (document.getElementById("deepseekResponse").classList.contains("excluded")) {
            recordModelVote("DeepSeek", "exclude");
          }
          if (document.getElementById("grokResponse").classList.contains("excluded")) {
            recordModelVote("Grok", "exclude");
          }

          // Aktualisiere die letzte verarbeitete Frage.
          lastQuestion = question;
        }

        // Setze den Konsens-Bereich (Spinner etc.) und rufe anschließend deinen Konsens-Endpunkt auf.
        const consensusDiv = document.getElementById("consensusResponse");
        const mainSpinner = '<span class="spinner"></span>';
        const diffSpinner = '<span class="spinner"></span>';

        consensusDiv.querySelector(".consensus-main p").innerHTML = mainSpinner;
        consensusDiv.querySelector(".consensus-differences p").innerHTML = diffSpinner;

      const consensus_model = document.getElementById("consensusModelDropdown").value;

      // Hole die Antwort-Boxen
      const openaiBox = document.getElementById("openaiResponse");
      const mistralBox = document.getElementById("mistralResponse");
      const claudeBox = document.getElementById("claudeResponse");
      const geminiBox = document.getElementById("geminiResponse");
      const deepseekBox = document.getElementById("deepseekResponse");
      const grokBox = document.getElementById("grokResponse");

      // Lies die Antworten (trim für überflüssige Leerzeichen)
      const answer_openai = openaiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_mistral = mistralBox.querySelector(".collapsible-content").innerText.trim();
      const answer_claude = claudeBox.querySelector(".collapsible-content").innerText.trim();
      const answer_gemini = geminiBox.querySelector(".collapsible-content").innerText.trim();
      const answer_deepseek = deepseekBox.querySelector(".collapsible-content").innerText.trim();
      const answer_grok = grokBox.querySelector(".collapsible-content").innerText.trim();

      // Überprüfe nur die Modelle, die nicht als "ausgeschlossen" markiert sind.
      if (
        !question ||
        !consensus_model ||
        (!openaiBox.classList.contains("excluded") && !answer_openai) ||
        (!mistralBox.classList.contains("excluded") && !answer_mistral) ||
        (!claudeBox.classList.contains("excluded") && !answer_claude) ||
        (!geminiBox.classList.contains("excluded") && !answer_gemini) ||
        (!deepseekBox.classList.contains("excluded") && !answer_deepseek) ||
        (!grokBox.classList.contains("excluded") && !answer_grok)
      ) {
        alert("Bitte zuerst eine Frage senden, alle Antworten abrufen und das Konsens‑Modell auswählen. Bitte Seite refreshen.");
        return;
      }

      // Hole den best markierten Modus (falls vorhanden)
      const bestBox = document.querySelector(".response-box.best");
      let best_model = bestBox ? bestBox.getAttribute("data-model") : "";

      // Die übrigen Parameter wie "excluded_models" werden wie bisher ermittelt
      const excludedModels = [];
      if (openaiBox.classList.contains("excluded")) {
        excludedModels.push(openaiBox.getAttribute("data-model"));
      }
      if (mistralBox.classList.contains("excluded")) {
        excludedModels.push(mistralBox.getAttribute("data-model"));
      }
      if (claudeBox.classList.contains("excluded")) {
        excludedModels.push(claudeBox.getAttribute("data-model"));
      }
      if (geminiBox.classList.contains("excluded")) {
        excludedModels.push(geminiBox.getAttribute("data-model"));
      }
      if (deepseekBox.classList.contains("excluded")) {
        excludedModels.push(deepseekBox.getAttribute("data-model"));
      }
      if (grokBox.classList.contains("excluded")) {
        excludedModels.push(grokBox.getAttribute("data-model"));
      }

      // Hole API Keys aus localStorage
      const openaiKey = localStorage.getItem("openaiKey") || "";
      const mistralKey = localStorage.getItem("mistralKey") || "";
      const anthropicKey = localStorage.getItem("anthropicKey") || "";
      const geminiKey = localStorage.getItem("geminiKey") || "";
      const deepseekKey= localStorage.getItem("deepseekKey") || "";
      const grokKey= localStorage.getItem("grokKey") || "";

      try {
        const response = await fetch("/consensus", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            id_token: id_token,
            useOwnKeys: useOwnKeys,
            question: question,
            answer_openai: answer_openai,
            answer_mistral: answer_mistral,
            answer_claude: answer_claude,
            answer_gemini: answer_gemini,
            answer_deepseek: answer_deepseek,
            answer_grok: answer_grok,
            best_model: best_model,
            consensus_model: consensus_model,
            excluded_models: excludedModels,
            openai_key: openaiKey,
            mistral_key: mistralKey,
            anthropic_key: anthropicKey,
            gemini_key: geminiKey,
            deepseek_key: deepseekKey,
            grok_key: grokKey
          })
        });
        const data = await response.json();
        if (response.ok) {
          // Aktualisiere den Konsens-Bereich und den Unterschiede-Bereich
          consensusDiv.querySelector(".consensus-main p").innerHTML = marked.parse(data.consensus_response);
          consensusDiv.querySelector(".consensus-differences p").innerHTML = marked.parse(data.differences || "Keine Unterschiede festgestellt.");

          // Parse den BestModel-Wert aus den Unterschieden und aktualisiere das Leaderboard in Firebase
          const bestModelFromConsensus = parseBestModel(data.differences);
          if (bestModelFromConsensus) {
            recordModelVote(bestModelFromConsensus, "BestModel");
          }
        } else {
          consensusDiv.querySelector(".consensus-main p").innerText = "Fehler: " + data.detail;
          consensusDiv.querySelector(".consensus-differences p").innerText = "";
        }
      } catch (error) {
        console.error("Error fetching consensus:", error);
        consensusDiv.querySelector(".consensus-main p").innerText = "Fehler bei der Konsens-Berechnung.";
        consensusDiv.querySelector(".consensus-differences p").innerText = "";
      }
    };
    
      // Testet die API Keys und aktualisiert das Feedback
      window.testAllKeys = async function() {
        const openaiKey = document.getElementById("openaiKey").value;
        const mistralKey = document.getElementById("mistralKey").value;
        const anthropicKey = document.getElementById("anthropicKey").value;
        const geminiKey = document.getElementById("geminiKey").value;
        const deepseekKey = document.getElementById("deepseekKey").value;
        const grokKey = document.getElementById("grokKey").value;
        localStorage.setItem("openaiKey", openaiKey);
        localStorage.setItem("mistralKey", mistralKey);
        localStorage.setItem("anthropicKey", anthropicKey);
        localStorage.setItem("geminiKey", geminiKey);
        localStorage.setItem("deepseekKey", deepseekKey);
        localStorage.setItem("grokKey", grokKey);
        const spinner = document.getElementById("apiSpinner");
        spinner.style.display = "inline-block";
        try {
          const response = await fetch("/check_keys", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              openai_key: openaiKey,
              mistral_key: mistralKey,
              anthropic_key: anthropicKey,
              gemini_key: geminiKey,
              deepseek_key: deepseekKey,
              grok_key: grokKey
            })
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText);
          }
          const data = await response.json();
          console.log("Response von /check_keys:", data);
          if (!data || !data.results) {
            throw new Error("Die Antwort enthält kein 'results'-Objekt. Response: " + JSON.stringify(data));
          }
          const openaiResult = data.results["OpenAI"];
          const mistralResult = data.results["Mistral"];
          const anthropicResult = data.results["Anthropic Claude"];
          const geminiResult = data.results["Google Gemini"];
          const deepseekResult = data.results["DeepSeek"];
          const grokResult = data.results["Grok"];
          const openaiFeedback = document.getElementById("openaiFeedback");
          const mistralFeedback = document.getElementById("mistralFeedback");
          const anthropicFeedback = document.getElementById("anthropicFeedback");
          const geminiFeedback = document.getElementById("geminiFeedback");
          const deepseekFeedback = document.getElementById("deepseekFeedback");
          const grokFeedback = document.getElementById("grokFeedback");
          openaiFeedback.innerHTML = openaiResult === "valid" ? "&#10003;" : "&#10007;";
          openaiFeedback.style.color = openaiResult === "valid" ? "green" : "red";
          mistralFeedback.innerHTML = mistralResult === "valid" ? "&#10003;" : "&#10007;";
          mistralFeedback.style.color = mistralResult === "valid" ? "green" : "red";
          anthropicFeedback.innerHTML = anthropicResult === "valid" ? "&#10003;" : "&#10007;";
          anthropicFeedback.style.color = anthropicResult === "valid" ? "green" : "red";
          geminiFeedback.innerHTML = geminiResult === "valid" ? "&#10003;" : "&#10007;";
          geminiFeedback.style.color = geminiResult === "valid" ? "green" : "red";
          deepseekFeedback.innerHTML = deepseekResult === "valid" ? "&#10003;" : "&#10007;";
          deepseekFeedback.style.color = deepseekResult === "valid" ? "green" : "red";
          grokFeedback.innerHTML = grokResult === "valid" ? "&#10003;" : "&#10007;";
          grokFeedback.style.color = grokResult === "valid" ? "green" : "red";
        } catch (error) {
          console.error("Fehler beim Testen der API Keys:", error);
          alert("Fehler beim Testen der API Keys: " + error.message);
        } finally {
          spinner.style.display = "none";
        }
      };
    
    });
</script>
<!-- Firebase-Code wird jetzt ausgelagert -->
<script type="module" src="/static/firebase.js"></script>
<!-- Login Modal -->
<div id="loginModal" class="modal">
  <div class="modal-content">
    <span class="close" id="closeLoginModal">&times;</span>
    <h2>Login</h2>
    <!-- Das Login-Formular hat autocomplete="on" -->
    <form id="loginForm" autocomplete="on">
      <input type="email" id="loginEmail" name="email" placeholder="Email" autocomplete="username">
      <input type="password" id="loginPassword" name="password" placeholder="Passwort" autocomplete="current-password">
      <button type="button" id="loginButton">Einloggen</button>
      <div id="loginError" class="error-message"></div><br/>
      <!-- Neuer Registrierungs-Button -->
      <button type="button" id="registerButton">Registrieren</button>
      <div id="registerError" class="error-message"></div><br/>
      <a href="#" id="forgotPasswordButton">Passwort vergessen?</a>
    </form>
  </div>
</div>
<div id="disclaimerPopup" class="popup">
  <p>Aktuell nur mit ChatGPT und Gemini, bald auch mit weiteren Modellen nutzbar!</p>
</div>
</body>
</html>